*vifm-app.txt*    For Vifm version 0.15  Last change: 2025 May 25

 Email for bugs and suggestions: <xaizek@posteo.net>

|vifm-options|            Command line arguments.
|vifm-general-keys|       General keys, that work in the most of modes.
|vifm-normal|             Normal mode keys.
|vifm-visual|             Visual mode keys.
|vifm-view|               View mode keys.
|vifm-command-line|       Command line mode keys.
|vifm-command-line-edit|  External editing of command line content.
|vifm-more|               More mode keys.
|vifm-commands|           How to use and set :commands.
|vifm-commands-bg|        Backgrounding of commands.
|vifm-cancellation|       Cancellation of commands.
|vifm-selection|          How selection is handled on launching.
|vifm-patterns|           Description of file match patterns.
|vifm-regexp|             Regular expressions.
|vifm-globs|              How globs work in vifm.
|vifm-set-options|        Available options.
|vifm-mappings|           Map arguments and special sequences.
|vifm-expression-syntax|  Syntax of supported expressions.
|vifm-functions|          List of builtin functions with description.
|vifm-menus-and-dialogs|  Keys and commands for menus and dialogs.
|vifm-menus-history|      Recalling previous menus.
|vifm-custom-views|       Differences between regular and custom views.
|vifm-compare-views|      Kinds, properties and differences of compare views.
|vifm-startup|            Determining of environment variables on startup.
|vifm-configure|          Configuration of vifm.
|vifm-sessions|           Managing sessions.
|vifm-fuse|               Using automated FUSE mounts.
|vifm-view-look|          Gives general overview of view displaying variants.
|vifm-ls-view|            Some details about ls-like view.
|vifm-column-view|        Column view configuration details.
|vifm-color-schemes|      Details on using color schemes in vifm.
|vifm-trash|              Details about trash directory in vifm.
|vifm-file-copying|       Additional information of file copying.
|vifm-clientserver|       Client-server communication.
|vifm-ext-rename|         About editing buffer of file names in an editor.
|vifm-mouse-using|        Using the mouse.
|vifm-plugin|             Using the vifm.vim plugin.
|vifm-reserved|           List of reserved commands.
|vifm-env-vars|           Environment variables that affect vifm or set by it.
|vifm-see-also|           Other resources about vifm.

Tag name structure:

          WHAT                 PREPEND     EXAMPLE~
      Normal mode command      vifm-       :help vifm-h
      Visual mode command      vifm-v_     :help vifm-v_u
      View mode command        vifm-q_     :help vifm-q_j
      Menu or dialog command   vifm-m_     :help vifm-m_zh
      Command-line command     vifm-:      :help vifm-:quit
      Command-line editing     vifm-c_     :help vifm-c_CTRL-H
      Command-line navigation  vifm-a_     :help vifm-a_CTRL-Y
      Vifm command argument    vifm--      :help vifm--f
      Option                   vifm-'      :help vifm-'wrap'

--------------------------------------------------------------------------------
*vifm-options*

General format:
vifm [OPTION]... [ path [ path ] ]

vifm starts in the current directory unless it is given a different directory
on the command line or |vifm-'vifminfo'| includes "savedirs" (in which case
last visited directories are used as defaults).

vifm -
Read list of files from standard input stream and compose custom view out of
them (see |vifm-custom-views|).  Current working directory is used as a base
for relative paths.

vifm /path/to/directory/one
or
vifm /path/to/directory/one /path/to/directory/two

Specifying two directories triggers split view even when vifm was in
single-view mode on finishing previous run.  To suppress this behaviour
|vifm-:only| command can be put in the vifmrc file.

When only one path argument is found on command-line, the left/top pane is
automatically set as the current view.

Paths to files are also allowed in case you want vifm to start with some
archive opened.

The other command line arguments are:
--select <path>                                *vifm---select*
    open parent directory of the given path and select specified file in it.
-f                                             *vifm--f*
    makes vifm instead of opening files write selection to $VIFM/vimfiles and
    quit.
--choose-files <path>|-                        *vifm---choose-files*
    sets output file to write selection into on exit instead of opening files.
    "-" means standard output.  Use empty value to disable it.
--choose-dir <path>|-                          *vifm---choose-dir*
    sets output file to write last visited directory into on exit.  "-" means
    standard output.  Use empty value to disable it.
--delimiter <delimiter>                        *vifm---delimiter*
    sets separator for list of file paths written out by vifm.  Empty value
    means null character.  Default is new line character.
--on-choose <command>                          *vifm---on-choose*
    sets command to be executed on selected files instead of opening them.
    The command may use any of |vifm-macros|.  The command is executed once for
    whole selection.
--plugins-dir <path>                           *vifm---plugins-dir*
    additional plugins directory (can appear multiple times).  The last one
    added has the highest priority.
--logging[=<startup log path>]                 *vifm---logging*
    log some operational details to $XDG_DATA_HOME/vifm/log or $VIFM/log.  If
    the optional startup log path is specified and permissions allow one to
    open it for writing, then logging of early initialization (before
    configuration directories are determined) is put there.
--server-list                                  *vifm---server-list*
    list available server names and exit.
--server-name <name>                           *vifm---server-name*
    name of target or this instance (sequential numbers are appended on name
    conflict).
--remote                                       *vifm---remote*
    sends the rest of the command line to another instance of vifm.
    --server-name is treated just like any other argument and should precede
    --remote on the command line.  When there is no server, quits silently.
    There is no limit on how many arguments can be processed.  One can combine
    --remote with -c <command> or +<command> to execute commands in already
    running instance of vifm.  See also |vifm-clientserver|.
--remote-expr                                  *vifm---remote-expr*
    passes expression to vifm server and prints result.  See also
    |vifm-clientserver|.
-c <command>, +<command>                       *vifm--c* *vifm--+c*
    run command-line mode <command> on startup.  Commands in such arguments
    are executed in the order they appear in command line.  Commands with
    spaces or special symbols must be enclosed in double or single quotes or
    all special symbols should be escaped (the exact syntax strongly depends
    on shell).  "+" argument is equivalent to "$" and thus picks last item
    of the view.
--help, -h                                     *vifm---help* *vifm--h*
    show a brief command summary and exit vifm.
--version, -v                                  *vifm---version* *vifm--v*
    show the version information and exit.
--no-configs                                   *vifm---no-configs*
    skip reading vifmrc and vifminfo.

See |vifm-startup| section below for the explanations on |vifm-$VIFM|.

-------------------------------------------------------------------------------
*vifm-general-keys*

Ctrl-C or Escape                               *vifm-Escape* *vifm-CTRL-C*
    cancel most operations (see |vifm-cancellation|), clear all selected files.
    In addition to that Escape also aborts waiting for more input when the
    current input is insufficient for determining the shortcut.

Ctrl-L                                         *vifm-CTRL-L*
    clear and redraw the screen.  Can also reload file list in appropriate
    modes (like normal and visual).

--------------------------------------------------------------------------------
*vifm-normal*

Basic Movement~

The basic vi key bindings are used to move through the files and pop-up windows.

k, gk or Ctrl-P - move cursor up one line.     *vifm-k* *vifm-gk* *vifm-CTRL-P*
j, gj or Ctrl-N - move cursor down one line.   *vifm-j* *vifm-gj* *vifm-CTRL-N*

h                                              *vifm-h*
    when |vifm-'lsview'| is off move up one directory (moves to parent
    directory node in tree view), otherwise move left one file.
l                                              *vifm-l*
    when |vifm-'lsview'| is off move into a directory or launch a file,
    otherwise move right one file.  See |vifm-selection|.

gg - move to the first line of the file list.  *vifm-gg*
G  - move to the last line in the file list.   *vifm-G*

gh                                             *vifm-gh*
    go up one directory regardless of view representation (regular,
    ls-like).  Also can be used to leave custom views including tree view.
gl or Enter                                    *vifm-gl* *vifm-Enter*
    enter directory or launch a file.  See |vifm-selection|.


H                                              *vifm-H*
    move to the first file in the window.
M                                              *vifm-M*
    move to the file in the middle of the window.
L                                              *vifm-L*
    move to the last file in the window.


Ctrl-F or Page Down - move forward one page.   *vifm-CTRL-F* *vifm-PageDown*
Ctrl-B or Page Up   - move back one page.      *vifm-CTRL-B* *vifm-PageUp*

Ctrl-D - jump back one half page.              *vifm-CTRL-D*
Ctrl-U - jump forward one half page.           *vifm-CTRL-U*

{n}%                                           *vifm-%*
    move to the file that is {n} percent from the top of the list (for
    example 25%).

0 or ^                                         *vifm-0* *vifm-^*
    move cursor to the first column.  See |vifm-'lsview'| option description.

$                                              *vifm-$*
    move cursor to the last column.  See |vifm-'lsview'| option description.

Space - switch file lists.                     *vifm-Space*

                                               *vifm-gt*
gt    - switch to the next tab (wrapping around).
{n}gt - switch to the tab number {n}.

                                               *vifm-gT*
gT    - switch to the previous tab (wrapping around).
{n}gT - switch to {n}-th previous tab (wrapping around).

Movement with Count~

Most movement commands also accept a count, 12j would move down 12 files.

[count]%
    move to percent of the file list.
[count]j
    move down [count] files.
[count]k
    move up [count] files.
[count]G or [count]gg
    move to list position [count].
[count]h
    go up [count] directories.

Scrolling panes~

zt - redraw pane with file in top of list.     *vifm-zt*
zz - redraw pane with file in center of list.  *vifm-zz*
zb - redraw pane with file in bottom of list.  *vifm-zb*

Ctrl-E                                         *vifm-CTRL-E*
    scroll pane one line down or column right (in transposed ls-like view).
Ctrl-Y                                         *vifm-CTRL-Y*
    scroll pane one line up or column left (in transposed ls-like view).

Pane manipulation~

Second character can be entered with or without Control key.

Ctrl-W H - move the pane to the far left.      *vifm-CTRL-W_H*
Ctrl-W J - move the pane to the very bottom.   *vifm-CTRL-W_J*
Ctrl-W K - move the pane to the very top.      *vifm-CTRL-W_K*
Ctrl-W L - move the pane to the far right.     *vifm-CTRL-W_L*

Ctrl-W h - switch to left pane.                *vifm-CTRL-W_h*
Ctrl-W j - switch to pane below.               *vifm-CTRL-W_j*
Ctrl-W k - switch to pane above.               *vifm-CTRL-W_k*
Ctrl-W l - switch to right pane.               *vifm-CTRL-W_l*

Ctrl-W b - switch to bottom-right window.      *vifm-CTRL-W_b*
Ctrl-W t - switch to top-left window.          *vifm-CTRL-W_t*

Ctrl-W p - switch to previous window.          *vifm-CTRL-W_p*
Ctrl-W w - switch to other pane.               *vifm-CTRL-W_w*

Ctrl-W o - leave only one pane.                *vifm-CTRL-W_o*
Ctrl-W s - split window horizontally.          *vifm-CTRL-W_s*
Ctrl-W v - split window vertically.            *vifm-CTRL-W_v*

Ctrl-W x - exchange panes.                     *vifm-CTRL-W_x*
Ctrl-W z - quit preview pane or view modes.    *vifm-CTRL-W_z*

Ctrl-W - - decrease size of the view by count. *vifm-CTRL-W_-*
Ctrl-W + - increase size of the view by count. *vifm-CTRL-W_+*
Ctrl-W < - decrease size of the view by count. *vifm-CTRL-W_<*
Ctrl-W > - increase size of the view by count. *vifm-CTRL-W_>*

Ctrl-W | - set current view size to count.     *vifm-CTRL-W_bar*
Ctrl-W _ - set current view size to count.     *vifm-CTRL-W__*
Ctrl-W = - make size of two views equal.       *vifm-CTRL-W_=*

For Ctrl-W +, Ctrl-W -, Ctrl-W <, Ctrl-W >, Ctrl-W | and Ctrl-W _
commands count can be given before and/or after Ctrl-W.  The
resulting count is a multiplication of those two.  So
"2 Ctrl-W 2 -" decreases window size by 4 lines or columns.

Ctrl-W | and Ctrl-W _ maximize current view by default.

Marks~

Marks are set the same way as they are in vi.
You can use these characters for marks [a-z][A-Z][0-9].

m[a-z][A-Z][0-9]                               *vifm-m*
    set a mark for the file at the current cursor position.
'[a-z][A-Z][0-9]                               *vifm-'*
    navigate to the file set for the mark.

There are also several special marks that can't be set manually:
 ' (single quote) - previously visited directory of the view, thus hitting
                    '' allows switching between two last locations
 < - the first file of the last visually selected block
 > - the last file of the last visually selected block

Searching~

                                               *vifm-/*
/regular expression
    search for files matching regular expression in forward direction and
    advance cursor to next match.
/
    perform forward search with top item of search pattern history.

                                               *vifm-?*
?regular expression
    search for files matching regular expression in backward direction and
    advance cursor to previous match.
?
    perform backward search with top item of search pattern history.

Trailing slash for directories is taken into account, so `/\/` searches for
directories and symbolic links to directories.  At the moment `//` works too,
but this can change in the future, so consider escaping the slash if not
typing pattern by hand.

Matches are automatically selected if |vifm-'hlsearch'| is set.  Enabling
|vifm-'incsearch'| makes search interactive.  |vifm-'ignorecase'| and
|vifm-'smartcase'| options affect case sensitivity of search queries as well
as local filter and other things detailed in the description of
|vifm-'caseoptions'|.

[count]n                                       *vifm-n*
    go to the next file matching last search pattern.  Takes last search
    direction into account.

[count]N                                       *vifm-N*
    go to the previous file matching last search pattern.  Takes last search
    direction into account.

If |vifm-'hlsearch'| option is set, hitting n/N to perform a search and go to
a matching item can reset existing selection in normal mode.  It happens when
there are no prior search results (i.e., no files with highlighting of the
matched part), otherwise the selection is left as is.  Resetting search
matches in any way (like running |vifm-:nohlsearch| or pressing |vifm-Escape|)
will force the search next time n/N is pressed and cause matching files to be
selected.

See also |vifm-regexp|.


[count]f[character]                            *vifm-f*
    search forward for file with [character] as first character in name.
    Search wraps around the end of the list.

[count]F[character]                            *vifm-F*
    search backward for file with [character] as first character in name.
    Search wraps around the end of the list.

[count]; - find the next match of f or F.      *vifm-;*
[count], - find the previous match of f or F.  *vifm-,*

Note: f, F, ; and , wrap around list beginning and end when they are used
alone and they don't wrap when they are used as selectors.

Filters~
                                               *vifm-filters*
There are three basic file filters:
 - dot files filter (does not affect "." and ".." special directories, whose
   appearance is controlled by the |vifm-'dotdirs'| option), see
   |vifm-'dotfiles'|
 - permanent filter
 - local filter (see |vifm-=|)

Permanent filter essentially allows defining a group of files names which are
not desirable to be seen by default, like temporary or backup files, which
might be created alongside normal ones.  Just like you don't usually need to
see hidden dot files (files starting with a dot).  Local filter on the other
hand is for temporary immediate filtering of file list at hand, to get rid of
uninterested files in the view or to make it possible to use % range in a
:command.

For the purposes of more deterministic editing permanent filter is split
into two parts:
 - one edited explicitly via |vifm-:filter| command
 - another one which is edited implicitly via |vifm-zf| shortcut
Files are tested against both parts and a match counts if at least one
of the parts matched.

Each file list has its own copy of each filter.

Filtered files are not checked in / search or :commands.

Files and directories are filtered separately.  This is done by appending
a slash to a directory name before testing whether it matches the filter.
Examples:
>
 " filter directories which names end with '.files'
 :filter /^.*\.files\/$/

 " filter files which names end with '.d'
 :filter {*.d}

 " filter files and directories which names end with '.o'
 :filter /^.*\.o\/?$/
<
See also |vifm-patterns| and |vifm-regexp|.

The basic Vim folding key-bindings are used for managing filters.

za - toggle visibility of dot files.           *vifm-za*
zo - show dot files.                           *vifm-zo*
zm - hide dot files.                           *vifm-zm*

zf - add selected files to permanent filter.   *vifm-zf*
zO - reset permanent filter.                   *vifm-zO*

zR - save and reset all filters.               *vifm-zR*
zr - clear local filter.                       *vifm-zr*
zM - restore all filters (undoes last zR).     *vifm-zM*

zd                                             *vifm-zd*
    exclude selection or current file from a custom view.  Does nothing for
    regular view.  For tree view excluding directory excludes that sub-tree.
    For compare views zd hides group of adjacent identical files, count can
    be specified as 1 to exclude just single file or selected items instead.
    Files excluded this way are not counted as filtered out and can't be
    returned unless view is reloaded.

=regular expression                            *vifm-=*
    filter out files that don't match regular expression.  Whether view is
    updated as regular expression is changed depends on the value of the
    |vifm-'incsearch'| option.  This kind of filter is automatically reset
    when directory is changed.

Tree-related Keys~

While some of the keys make sense outside of tree-view, they are most useful
in trees.

[z  go to first sibling of current entry.      *vifm-[z*
]z  go to last sibling of current entry.       *vifm-]z*


zj                                             *vifm-zj*
    go to next directory sibling of current entry or do nothing.

zk                                             *vifm-zk*
    go to previous directory sibling of current entry or do nothing.


zx                                             *vifm-zx*
    toggle fold under the cursor or parent entry of the current file if cursor
    is not on a directory.

Other Normal Mode Keys~

[count]:                                       *vifm-:*
    enter command line mode.  [count] generates range.

q:                                             *vifm-q:*
    open external editor to prompt for command-line command.  See
    |vifm-command-line-edit| section for details.

q/                                             *vifm-q/*
    open external editor to prompt for search pattern to be searched
    in forward direction.  See |vifm-command-line-edit| section for
    details.

q?                                             *vifm-q?*
    open external editor to prompt for search pattern to be searched
    in backward direction.  See |vifm-command-line-edit| section for
    details.

q=                                             *vifm-q=*
    open external editor to prompt for filter pattern.  See
    |vifm-command-line-edit| section for details.  Unlike other q{x}
    commands this one doesn't work in Visual mode.

[count]!! and [count]!<selector>               *vifm-!!*
    enter command line mode with entered ! command.  [count] modifies range.

Ctrl-O                                         *vifm-CTRL-O*
    go backwards through directory history of current view.  Nonexistent
    directories are automatically skipped.

Ctrl-I or Tab                                  *vifm-CTRL-I* *vifm-Tab*
    if |vifm-'cpoptions'| contains "t" flag (|vifm-cpo-t|), <tab> and
    <c-i> switch active pane just like |vifm-Space| does, otherwise it
    goes forward through directory history of current view.  Nonexistent
    directories are automatically skipped.

Ctrl-G                                         *vifm-CTRL-G*
    show a dialog with detailed information about current file.
    See |vifm-menus-and-dialogs| for controls.

Shift-Tab                                      *vifm-SHIFT-Tab*
    enter view mode (|vifm-view|, works only after activating view pane
    with |vifm-:view| command).


ga                                             *vifm-ga*
    calculate directory size.  Uses cached directory sizes when possible
    for better performance.  As a special case calculating size of ".." entry
    results in calculation of size of current directory.
gA                                             *vifm-gA*
    like ga, but force update.  Ignores old values of directory sizes.

If file under cursor is selected, each selected item is processed,
otherwise only current file is updated.


gf                                             *vifm-gf*
    find link destination (like l with |vifm-'followlinks'| off, but also
    finds directories).  On Windows additionally follows .lnk-files.

gF                                             *vifm-gF*
    Same as gf, but resolves final path of the chain of symbolic links.

                                               *vifm-gr*
gr                                             {only for MS-Windows}
    same as l key, but tries to run program with administrative
    privileges.


av                                             *vifm-av*
    go into visual mode for updating current selection, any existing selection
    is preserved.

gv                                             *vifm-gv*
    go into visual mode restoring last selection.

[reg]gs                                        *vifm-gs*
    If register is present, then all files listed in that register that are
    visible in current view are selected.

    When no register is specified, restore the last selection saved for this
    view (similar to what |vifm-gv| does for visual mode selection).  When you
    leave a directory, its saved selection is remembered for that path and
    visiting the directory again restores it.  Selection for up to 10 distinct
    file-system locations are remembered.


gu<selector>                                   *vifm-gu*
    make names of selected files lowercase.
[count]guu or [count]gugu                      *vifm-guu* *vifm-gugu*
    make names of [count] files starting from the current one lowercase.
    Without [count] only current file is affected.

gU<selector>                                   *vifm-gU*
    make names of selected files uppercase.
[count]gUU or [count]gUgU                      *vifm-gUU* *vifm-gUgU*
    make names of [count] files starting from the current
    one uppercase.  Without [count] only current file is affected.


e - explore file in the current pane.          *vifm-e*

i                                              *vifm-i*
    handle file (even if it's an executable and |vifm-'runexec'| option is
    set).


cw                                             *vifm-cw*
    change word is used to rename a file or files.  If multiple files are
    selected, behaves as |vifm-:rename| command run without arguments.

cW                                             *vifm-cW*
    change WORD is used to change only name of file (without extension).

cl                                             *vifm-cl*
    change link target.  If multiple files are selected, an editor is spawn
    to edit paths.

                                               *vifm-co*
co - change file owner.                        {only for *nix}

                                               *vifm-cg*
cg - change file group.                        {only for *nix}

[count]cp                                      *vifm-cp*
    change file attributes (permission on *nix and properties on
    Windows).  If [count] is specified, it's treated as numerical argument
    for non-recursive `chmod` command (of the form `[0-7]{3,4}`).  See
    |vifm-menus-and-dialogs| for controls.

[count]C                                       *vifm-C*
    clone file(s) [count] times.

[reg][count]dd                                 *vifm-dd*
    move files to |vifm-trash| directory if |vifm-'trash'| option is set,
    otherwise delete them permanently.

    When |vifm-cpo-s| is present in |vifm-'cpoptions'|, operates on selected
    files or, in the absence of selection, the current one.  When the flag
    isn't set, always operates on the current file only.
[reg]d[count]<selector>                        *vifm-d*
    like dd, but accepts motions/selectors.

[count]DD and D[count]<selector>               *vifm-D* *vifm-DD*
    like dd and d<selector>, but always omits |vifm-trash| directory (even
    when |vifm-'trash'| option is set).  Affected by |vifm-cpo-s|.

[reg][count]yy or [reg][count]Y                *vifm-yy* *vifm-Y*
    yank files.

    When |vifm-cpo-s| is present in |vifm-'cpoptions'|, operates on selected
    files or, in the absence of selection, the current one.  When the flag
    isn't set, always operates on the current file only.
[reg]y[count]<selector>                        *vifm-y*
    yank files specified by motion/selector.

[reg]p                                         *vifm-p*
    copy yanked files to the current directory or move the files to the
    current directory if they were deleted with dd or :d[elete] or yanked
    from |vifm-trash| directory.  Also see |vifm-file-copying|.

[reg]P                                         *vifm-P*
    move the last yanked files.  The advantage of using P instead of d
    followed by p is that P moves files only once.  This isn't important in
    case you're moving files in the same file system where your home
    directory is, but using P to move files on some other file system (or
    file systems, in case you want to move files from fs1 to fs2 and your
    home is on fs3) can save your time.

                                               *vifm-al*
[reg]al - put symbolic links with absolute paths.
                                               *vifm-rl*
[reg]rl - put symbolic links with relative paths.

t - select or unselect (tag) the current file. *vifm-t*

u - undo last change.                          *vifm-u*
Ctrl-R - redo last change.                     *vifm-CTRL-R*

dp                                             *vifm-dp*
    in compare view of "ofboth grouppaths" kind makes corresponding entries
    of the other pane equal to the current one.  If at least one file is
    selected, the command processes selection, otherwise current file.

    The semantics is as follows:
     - nothing is done for identical entries
     - if file is missing in current view, its pair gets removed
     - if file is missing or differs in other view, it is replaced
     - file pairs are defined by matching relative paths

    File removal obeys |vifm-'trash'| option.  When the option is enabled, the
    operation can be undone/redone (although results won't be visible
    automatically).

    Unlike in Vim, this operation is performed on a single line rather than
    a set of adjacent changes.
do                                             *vifm-do*
    same as dp, but applies changes in the opposite direction.

v or V                                         *vifm-v* *vifm-V*
    start visual selection of files, clears current selection.


[count]Ctrl-A                                  *vifm-CTRL-A*
    increment first number in file name by [count] (1 by default).

[count]Ctrl-X                                  *vifm-CTRL-X*
    decrement first number in file name by [count] (1 by default).


ZQ - same as :quit!.                           *vifm-ZQ*
ZZ - same as |vifm-:quit|.                       *vifm-ZZ*


.                                              *vifm-.*
    repeat last command-line command (not normal mode command) of this
    run (does nothing right after startup or |vifm-:restart| command).
    The command doesn't depend on command-line history and can be used
    with completely disabled history.


(                                              *vifm-(*
    go to previous group.  Groups are defined by primary sorting key.
    For name and iname members of each group have same first letter,
    for all other sorting keys vifm uses size, uid, ...

)                                              *vifm-)*
    go to next group.  See ( key description above.


{                                              *vifm-{*
    speeds up navigation to closest previous entry of the opposite type by
    moving to the first file backwards when cursor is on a directory and
    to the first directory backwards when cursor is on a file.  This is
    essentially a special case of ( that is locked on "dirs".

}                                              *vifm-}*
    same as {, but in forward direction.


[c                                             *vifm-[c*
    go to previous mismatched entry in directory comparison view or do
    nothing.

]c                                             *vifm-]c*
    go to next mismatched entry in directory comparison view or do nothing.


[d                                             *vifm-[d*
    go to previous directory entry or do nothing.

]d                                             *vifm-]d*
    go to next directory entry or do nothing.


[r  same as |vifm-:siblprev|.                    *vifm-[r*
]r  same as |vifm-:siblnext|.                    *vifm-]r*
[R  same as |vifm-:siblprev|!.                   *vifm-[R*
]R  same as |vifm-:siblnext|!.                   *vifm-]R*


[s                                             *vifm-[s*
    go to the previous selected entry or do nothing.

]s                                             *vifm-]s*
    go to the next selected entry or do nothing.

[S  same as |vifm-[s|, but wraps.              *vifm-[S*
]S  same as |vifm-]s|, but wraps.              *vifm-]S*

Using Count~
                                               *vifm-count* *vifm-[count]*
You can use count with commands like yy.

[count]yy yank (count + 1) files starting from current cursor position
downward.

Or you can use count with motions passed to y, d or D.

d[count]j delete (count + 1) files starting from current cursor position
downward.

Registers~
                                               *vifm-registers*
vifm supports multiple registers to temporary store lists of yanked and/or
deleted files.

Registers are specified by pressing double quote key followed by a register
name before typing a command.  Count is specified after a register name.
By default commands use unnamed register, which has double quote as its name.

Though all commands accept registers, most commands ignore them (for
example, |vifm-H| or |vifm-CTRL-U|).  Other commands fill a register, append
new files to it or use it as a source of list of files.

Presently vifm supports ", _, a-z and A-Z characters as register names.

As mentioned above " is unnamed register and has special meaning of the
default register.  Every time a named register (a-z and A-Z) is used, unnamed
register is updated to contain the same list of files.

_ is black hole register.  It can be used for writing, but its list is always
empty.

Registers with names from a to z and from A to Z are named ones.
Lowercase registers are cleared before adding new files, while uppercase ones
aren't and should be used to append new files to the existing file list
of a corresponding lowercase register (A for a, B for b, ...).

Registers contain each file at most once.  Nonexistent files are dropped from
them.  In particular, registers can be changed on |vifm-:empty| command if
they include files under |vifm-trash| directory.

Example: >
  "a2yy
puts names of two files to register a (and to the unnamed register), >
  "Add
removes one file and append its name to register a (and to the unnamed
register), >
  p or "ap or "Ap
inserts previously yanked and deleted files into current directory.

Selectors~
                                               *vifm-selectors*
y, d, D, !, gu and gU commands accept selectors.  You can combine them with
any of selectors below to quickly remove or yank several files.

j, k, gg, G, H, L, M, %, f, F, ;, comma, ', ^, 0 and $ can be used as
selectors for several commands.
Also following selectors can be used:
 a - all files in current view
 s - selected files
 S - all files except selected

For example:
dj - delete file under cursor and one below.
d2j - delete file under cursor and two below.
y6gg - yank all files from cursor position to 6th file in the list.

When you pass a count to whole command and its selector they are
multiplied. So:
2d2j - delete file under cursor and four below.
2dj - delete file under cursor and two below.
2y6gg - yank all files from cursor position to 12th file in the list.

--------------------------------------------------------------------------------
*vifm-visual*

Visual mode has two generic operating submodes:
 - plain selection as it is in Vim;
 - selection editing submode.

Both modes select files in range from cursor position at which visual mode was
entered to current cursor position (let's call it "selection region").  Each of
two borders can be adjusted by swapping them via |vifm-v_o| or |vifm-v_O| keys
and updating cursor position with regular cursor motion keys.  Obviously, once
initial cursor position is altered this way, real start position becomes
unavailable.

Plain Vim-like visual mode starts with cleared selection, which is not restored
on rejecting selection (|vifm-v_Escape|, |vifm-v_CTRL-C|, |vifm-v_v|,
|vifm-v_V|).  Contrary to it, selection editing doesn't clear previously
selected files and restores them after reject.  Accepting selection by
performing an operation on selected items (e.g. yanking them via |vifm-y|)
moves cursor to the top of current selection region (not to the top most
selected file of the view).

In turn, selection editing supports three types of editing (look at status bar
to know which one is currently active):
 - append - amend selection by selecting elements in selection region;
 - remove - amend selection by deselecting elements in selection region;
 - invert - amend selection by inverting selection of elements in selection
            region.
No matter how you activate selection editing it starts in "append" activated.
One can switch type of operation (in the order given above) via
|vifm-v_CTRL-G| key.

Almost all normal mode keys work in visual mode, but instead of accepting
selectors they operate on selected items.

Enter                                          *vifm-v_Enter*
    save selection and go back to normal mode not moving cursor.

av                                             *vifm-v_av*
    leave visual mode if in amending mode (restores previous selection),
    otherwise switch to amending selection mode.

gv                                             *vifm-v_gv*
    restore previous visual selection.

Escape, Ctrl-C                                 *vifm-v_Escape* *vifm-v_CTRL-C*
v, V                                           *vifm-v_v* *vifm-v_V*
    leave visual mode if not in amending mode, otherwise switch to normal
    visual selection.

Ctrl-G                                         *vifm-v_CTRL-G*
    switch type of amending by round robin scheme: append -> remove -> invert.

:                                              *vifm-v_:*
    enter command line mode.  Selection is cleared on leaving the mode.

o, O                                           *vifm-v_o* *vifm-v_O*
    switch active selection bound.

gu, u                                          *vifm-v_gu* *vifm-v_u*
    make names of selected files lowercase.

gU, U                                          *vifm-v_gU* *vifm-v_U*
    make names of selected files uppercase.

cl                                             *vifm-v_cl*
    change target of symbolic link(s).

cw                                             *vifm-v_cw*
    same as running |vifm-:rename| command without arguments.

--------------------------------------------------------------------------------
*vifm-view*

This mode tries to imitate the less program.  List of builtin shortcuts can be
found below.  Shortcuts can be customized using |vifm-:qmap|, |vifm-:qnoremap| and
|vifm-:qunmap| command-line commands.

Shift-Tab, Tab                                 *vifm-q_SHIFT-Tab* *vifm-q_Tab*
q, Q, ZZ                                       *vifm-q_q* *vifm-q_Q* *vifm-q_ZZ*
    return to normal mode.


[count]e, [count]Ctrl-E                        *vifm-q_e* *vifm-q_CTRL-E*
[count]j, [count]Ctrl-N                        *vifm-q_j* *vifm-q_CTRL-N*
[count]Enter                                   *vifm-q_Enter*
    scroll forward one line (or [count] lines).

[count]y, [count]Ctrl-Y                        *vifm-q_y* *vifm-q_CTRL-Y*
[count]k, [count]Ctrl-K                        *vifm-q_k* *vifm-q_CTRL-K*
[count]Ctrl-P                                  *vifm-q_CTRL-P*
    scroll backward one line (or [count] lines).


[count]f, [count]Ctrl-F                        *vifm-q_f* *vifm-q_CTRL-F*
[count]Ctrl-V, [count]Space                    *vifm-q_CTRL-V* *vifm-q_Space*
    scroll forward one window (or [count] lines).

[count]b, [count]Ctrl-B                        *vifm-q_b* *vifm-q_CTRL-B*
[count]Alt-V                                   *vifm-q_ALT-V*
    scroll backward one window (or [count] lines).

[count]z                                       *vifm-q_z*
    scroll forward one window (and set window to [count]).

[count]w                                       *vifm-q_w*
    scroll backward one window (and set window to [count]).

[count]Alt-Space                               *vifm-q_ALT-Space*
    scroll forward one window, but don't stop at end-of-file.


[count]d, [count]Ctrl-D                        *vifm-q_d* *vifm-q_CTRL-D*
    scroll forward one half-window (and set half-window to [count]).

[count]u, [count]Ctrl-U                        *vifm-q_u* *vifm-q_CTRL-U*
    scroll backward one half-window (and set half-window to [count]).


r, Ctrl-R                                      *vifm-q_r* *vifm-q_CTRL-R*
Ctrl-L                                                  *vifm-q_CTRL-L*
    repaint screen.

R                                              *vifm-q_R*
    reload view preserving scroll position.

F                                              *vifm-q_F*
    toggle automatic forwarding.  Roughly equivalent to periodic file reload
    and scrolling to the bottom.  The behaviour is similar to `tail -F` or F
    key in less.

a                                              *vifm-q_a*
    switch to the next viewer.  Does nothing for preview constructed via `%q`
    macro.
A                                              *vifm-q_A*
    switch to the previous viewer.  Does nothing for preview constructed
    via `%q` macro.
i                                              *vifm-q_i*
    toggle raw mode (ignoring of defined viewers).  Does nothing for preview
    constructed via `%q` macro.


[count]/pattern                                *vifm-q_/*
    search forward for ([count]-th) matching line.
[count]?pattern                                *vifm-q_?*
    search backward for ([count]-th) matching line.

[count]n                                       *vifm-q_n*
    repeat previous search (for [count]-th occurrence).
[count]N                                       *vifm-q_N*
    repeat previous search in reverse direction (for [count]-th occurrence).


[count]g, [count]<                             *vifm-q_g* *vifm-q_<*
[count]Alt-<                                   *vifm-q_ALT-<*
    scroll to the first line of the file (or line [count]).

[count]G, [count]>                             *vifm-q_G* *vifm-q_>*
[count]Alt->                                   *vifm-q_ALT->*
    scroll to the last line of the file (or line [count]).

[count]p, [count]%                             *vifm-q_p* *vifm-q_%*
    scroll to the beginning of the file (or N percent into file).

v                                              *vifm-q_v*
    invoke an editor to edit the current file being viewed.  The command for
    editing is taken from the |vifm-'vicmd'| or |vifm-'vixcmd'| option value and
    extended with middle line number prepended by a plus sign and name of the
    current file.


All "Ctrl-W x" keys above work the same was as in |vifm-normal| mode.  Active
mode is automatically changed on navigating among windows.  When less-like
activated on file preview is left using one by "Ctrl-W x" keys, its state is
stored until another file is displayed using preview (it's possible to leave
the mode, hide preview pane, do something else, then get back to the file and
show preview pane again with previously stored state in it).

--------------------------------------------------------------------------------
*vifm-command-line*

These keys are available in all submodes of the command line mode: command,
search, prompt and filtering.

Down, Up, Left, Right, Home, End and Delete are extended keys and they are not
available if vifm is compiled with --disable-extended-keys option.

Esc, Ctrl-C                                    *vifm-c_Esc* *vifm-c_CTRL-C*
    leave command line mode, cancels input.  Cancelled input is saved into
    appropriate history and can be recalled later.

Ctrl-M, Enter                                  *vifm-c_CTRL-M* *vifm-c_Enter*
    execute command and leave command line mode.

Ctrl-I, Tab                                    *vifm-c_CTRL-I* *vifm-c_Tab*
    complete command or its argument on editing of a :command, complete file
    names in file name prompts, move cursor onto the next search match in
    file search prompt (including in navigation) when |vifm-'incsearch'| is set.
Shift-Tab                                      *vifm-c_SHIFT-Tab*
    complete in reverse order or move cursor onto the previous file search
    match.

Ctrl-_                                         *vifm-c_CTRL-_*
    stop completion and restore original input.

Ctrl-B, Left  - move cursor to the left.       *vifm-c_CTRL-B* *vifm-c_Left*
Ctrl-F, Right - move cursor to the right.      *vifm-c_CTRL-F* *vifm-c_Right*

Ctrl-A, Home - go to start of the line         *vifm-c_CTRL-A* *vifm-c_Home*
Ctrl-E, End  - go to end of the line.          *vifm-c_CTRL-E* *vifm-c_End*

Alt-B - go to beginning of previous word.      *vifm-c_ALT-B*
Alt-F - go to end of next word.                *vifm-c_ALT-F*

Ctrl-U                                         *vifm-c_CTRL-U*
    remove characters from cursor position till beginning of the line.
Ctrl-K                                         *vifm-c_CTRL-K*
    remove characters from cursor position till end of the line.

Ctrl-H                                         *vifm-c_CTRL-H*
Backspace                                      *vifm-c_Backspace*
    remove single character before the cursor.
Ctrl-D, Delete                                 *vifm-c_CTRL-D* *vifm-c_Delete*
    remove single character under the cursor.

Ctrl-W                                         *vifm-c_CTRL-W*
    remove characters from cursor position till beginning of previous word.
Alt-D                                          *vifm-c_ALT-D*
    remove characters from cursor position till beginning of next word.

Ctrl-T                                         *vifm-c_CTRL-T*
    swap the order of current and previous characters and move cursor forward
    or, if cursor past the end of line, swap the order of two last characters
    in the line.

Alt-.                                          *vifm-c_ALT-.*
    insert last part of previous command to current cursor position.
    Each next call inserts part of previous command.

Ctrl-G                                         *vifm-c_CTRL-G*
    edit command-line content in external editor.  See
    |vifm-command-line-edit| section for details.

Ctrl-N                                         *vifm-c_CTRL-N*
    recall more recent command-line from history.
Ctrl-P                                         *vifm-c_CTRL-P*
    recall older command-line from history.

Up                                             *vifm-c_Up*
    recall more recent command-line from history, that begins as the current
    command-line.
Down                                           *vifm-c_Down*
    recall older command-line from history, that begins as the current
    command-line.

Ctrl-] - trigger abbreviation expansion.       *vifm-c_CTRL-]*

Ctrl-R =                                       *vifm-c_CTRL-R_=*
    insert result of evaluating an expression.  Expression is to be entered
    via nested command-line prompt (where this key does nothing).  Expansion
    of an erroneous expression is empty.

Fast navigation~

In order to streamline navigation through directory tree, you can enter a
special form of command-line mode from search or local filter prompt.  Once
activated, pressing Enter opens currently selected directory and clears the
prompt in anticipation of the next component of the path.  If entry under the
cursor is a file, it is opened and the mode is finished.

This behaviour is embedded in a command-line mode, but doesn't update input
histories nor expands abbreviations and redefines some of the mode's mappings
for the purpose of faster navigation through the file system rather than
command-line editing.  When on, prompt gets "nav" prefix.

You can enable this behaviour on search by default via a mapping like: >
    nnoremap / /<c-y>

Ctrl-Y                                         *vifm-c_CTRL-Y*
    enter navigation mode.  Works only for search and local filter started
    from a normal mode and only when |vifm-'incsearch'| is set
    (|vifm-'wrapscan'| is also nice to have set for search).

Ctrl-Y                                         *vifm-a_CTRL-Y*
    return to a regular command-line mode.

Enter, Right                                   *vifm-a_Enter* *vifm-a_Right*
    either enter a directory under the cursor without leaving the mode and
    clear the prompt or leave the mode for files.  If |vifm-'navoptions'|
    specifies "open:all" a file under the cursor is opened after leaving the
    mode.
Ctrl-O, Left                                   *vifm-a_CTRL-O* *vifm-a_Left*
    go to parent directory.
Ctrl-J                                         *vifm-a_CTRL-J*
    leave the mode without undoing cursor position or filter state.

Ctrl-N, Down                                   *vifm-a_CTRL-N* *vifm-a_Down*
    move view cursor down.
Ctrl-P, Up                                     *vifm-a_CTRL-P* *vifm-a_Up*
    move view cursor up.

Page Down                                      *vifm-a_PageDown*
    scroll view down.
Page Up                                        *vifm-a_PageUp*
    scroll view up.

Home                                           *vifm-a_Home*
    move view cursor to the first item.
End                                            *vifm-a_End*
    move view cursor to the last item.

Pasting special values~

The shortcuts listed below insert specified values into current cursor
position.  Last key of every shortcut references value that it inserts:

 - c - [c]urrent file
 - d - [d]irectory path
 - e - [e]xtension of a file name
 - r - [r]oot part of a file name
 - t - [t]ail part of directory path

 - a - [a]utomatic filter
 - m - [m]anual filter
 - = - local filter, which is bound to "=" in normal mode

Values related to filelist in current pane are available through Ctrl-X
prefix, while values from the other pane have doubled Ctrl-X key as their
prefix (doubled Ctrl-X is presumably easier to type than uppercase
letters; it's still easy to remap the keys to correspond to names of
similar macros).

Ctrl-X c                                       *vifm-c_CTRL-X_c*
    name of the current file of the active pane.

Ctrl-X d                                       *vifm-c_CTRL-X_d*
    path to the current directory of the active pane.

Ctrl-X e                                       *vifm-c_CTRL-X_e*
    extension of the current file of the active pane.

Ctrl-X r                                       *vifm-c_CTRL-X_r*
    name root of current file of the active pane.

Ctrl-X t                                       *vifm-c_CTRL-X_t*
    the last component of path to the current directory of the active pane.

Ctrl-X Ctrl-X c                                *vifm-c_CTRL-X_CTRL-X_c*
    name of the current file of the inactive pane.

Ctrl-X Ctrl-X d                                *vifm-c_CTRL-X_CTRL-X_d*
    path to the current directory of the inactive pane.

Ctrl-X Ctrl-X e                                *vifm-c_CTRL-X_CTRL-X_e*
    extension of the current file of the inactive pane.

Ctrl-X Ctrl-X r                                *vifm-c_CTRL-X_CTRL-X_r*
    name root of current file of the inactive pane.

Ctrl-X Ctrl-X t                                *vifm-c_CTRL-X_CTRL-X_t*
    the last component of path to the current directory of the inactive pane.


Ctrl-X a                                       *vifm-c_CTRL-X_a*
    value of implicit permanent filter (old name "automatic") of the active
    pane.

Ctrl-X m                                       *vifm-c_CTRL-X_m*
    value of explicit permanent filter (old name "manual") of the active
    pane.

Ctrl-X =                                       *vifm-c_CTRL-X_=*
    value of local filter of the active pane.

Ctrl-X /                                       *vifm-c_CTRL-X_/*
    last pattern from search history.

--------------------------------------------------------------------------------
*vifm-command-line-edit*

vifm provides a facility to edit several kinds of data, that is usually edited
in command-line mode, in external editor (using command specified by
|vifm-'vicmd'| or |vifm-'vixcmd'| option).  This has at least two advantages
over built-in command-line mode:
 - one can use full power of Vim to edit text;
 - finding and reusing history entries becomes possible.

The facility is supported by four input submodes of the command-line:
 - command;
 - forward search;
 - backward search;
 - file rename (see |vifm-cw| and |vifm-cW|).

Editing command-line using external editor is activated by the |vifm-c_CTRL-G|
shortcut.  It's also possible to do almost the same from Normal and Visual
modes using |vifm-q:|, |vifm-q/| and |vifm-q?| commands.

Temporary file created for the purpose of editing the line has the following
structure:
 1. First line, which is either empty or contains text already entered in
    command-line.
 2. 2nd and all other lines with history items starting with the most recent
    one.  Altering this lines in any way won't change history items stored by
    vifm.

After editing application is finished the first line of the file is taken as
the result of operation, when the application returns zero exit code.  If the
application returns an error (see |:cquit| command in Vim), all the edits made
to the file are ignored, but the initial value of the first line is saved in
appropriate history.

--------------------------------------------------------------------------------
*vifm-more*
                                               *vifm-pager*

This is the mode that appears when status bar content is so big that it
doesn't fit on the screen.  One can identify the mode by "-- More --" message
at the bottom.

The following keys are handled in this mode:

Enter, Ctrl-J, j or Down - scroll one line down.
Backspace, k or Up - scroll one line up.

d - scroll one page (half of a screen) down.
u - scroll one page (half of a screen) up.

Space, f or PageDown - scroll down a screen.
b or PageUp - scroll up a screen.

G - scroll to the bottom.
g - scroll to the top.

q, Escape or Ctrl-C - quit the mode.
: - switch to command-line mode.

--------------------------------------------------------------------------------
*vifm-commands*

vifm-commands are executed with :command_name<Enter>

Commented out lines should start with the double quote symbol ("), which may be
preceded by whitespace characters intermixed with colons.  Inline comments can
be added at the end of the line after double quote symbol, only last line of a
multi-line command can contain such comment.  Not all commands support inline
comments as it's not always possible to identify one unambiguously:
 - the syntax conflicts with names of registers
 - the syntax conflicts with quoting arguments to commands
 - mapping/abbreviation commands can expand to arbitrary sequences which can
   look like a comment without being one

Most of the commands have two forms: complete and the short one.
Example: >
    :noh[lsearch]
This means the complete command is nohlsearch, and the short one is noh.

                                               *vifm-commands-and-selection*
Most of command-line commands completely reset selection in the current view.
However, there are several exceptions:
 - `:invert s` most likely leaves some files selected;
 - :view command;
 - :normal command (when it doesn't leave command-line mode);
 - :if and :else commands don't affect selection on successful execution.

                                               *vifm-:bar*
'|' can be used to separate commands, so you can give multiple commands in one
line.  If you want to use '|' in an argument, precede it with '\'.

These commands see '|' as part of their arguments even when it's escaped:

    :[range]!
    :amap
    :anoremap
    :autocmd
    :cabbrev
    :cmap
    :cnoreabbrev
    :cnoremap
    :command
    :dmap
    :dnoremap
    :filetype
    :fileviewer
    :filextype
    :keepsel
    :map
    :mmap
    :mnoremap
    :nmap
    :nnoremap
    :noremap
    :normal
    :qmap
    :qnoremap
    :vmap
    :vnoremap
    :wincmd
    :windo
    :wingo
    :winrun

To be able to use another command after one of these, wrap it with the
|vifm-:execute| command.  An example: >

    if filetype('.') == 'reg' | execute '!!echo regular file' | endif
<
                                               *vifm-:range*
:number - move to the file number.
:12 would move to the 12th file in the list.
:0 move to the top of the list.
:$ move to the bottom of the list.
See |vifm-ranges| for the ranges implemented.

:[count]command
The only builtin :[count]command are :[count]d[elete] and :[count]y[ank].
Examples:
:d3 - would delete three files starting at the current file position
    moving down.
:3d - would delete one file at the third line in the list.

See |vifm-reserved| for a list of reserved command names.

The builtin commands are:

                                               *vifm-:!*
:[range]!command
    execute command via shell.  Accepts macros.
:[range]!command &
    Same as above, but the command is run in the background using vifm's means.
    Programs that write to stderr create error dialogs showing errors of the
    command.  Note the space before ampersand symbol, if you omit it, command
    is run in the background using job control of your shell.
                                               *vifm-:!!*
:[range]!!command
    same as :!, but pauses before returning.
:!!
    repeat the last command.

                                               *vifm-:alink*
:[range]alink[!?]
    create absolute symbolic links to files in directory of inactive view.
    With "?" prompts for destination file names in an editor.  "!" forces
    overwrite.
:[range]alink[!] path
    create absolute symbolic links to files in directory specified by the path
    (absolute or relative to directory of inactive view).
:[range]alink[!] name1 name2...
    create absolute symbolic links of files in directory of other view giving
    each next link a corresponding name from the argument list.
:[range]alink[!?] -skip ...
    see |vifm-skip-param|.

                                               *vifm-:apropos*
:apropos keyword...
    create a menu of items returned by the apropos command.  Selecting an item
    in the menu opens corresponding man page.  By default the command relies
    on the external "apropos" utility, which can be customized by altering
    value of the |vifm-'aproposprg'| option.  See |vifm-menus-and-dialogs| for
    controls.
:apropos
    repeat last :apropos command.

                                               *vifm-:autocmd* *vifm-:au*
:au[tocmd] {event} {pat} {cmd}
    register autocommand for the {event}, which can be:
      - DirEnter - triggered after directory is changed
    Event name is case insensitive.

    {pat} is a comma-separated list of modified globs patterns, which can
    contain tilde or environment variables.  All paths use slash ('/') as
    directory separator.  The pattern can start with a '!', which negates it.
    Patterns that do not contain slashes are matched against the last item of
    the path only (e.g. "dir" in "/path/dir").  Literal comma can be entered by
    doubling it.  Two modifications to globs matching are as follows:
      - *  - never matches a slash (i.e., can signify single directory level)
      - ** - matches any character (i.e., can match path of arbitrary depth)

    {cmd} is a :command or several of them separated with '|'.

    Examples of patterns:
      - `conf.d`      - matches conf.d directory anywhere
      - `*.d`         - matches directories ending with ".d" anywhere
      - `**.git`      - matches something.git, but not .git anywhere
      - `**/.git/**`  - matches /path/.git/objects, but not /path/.git
      - `**/.git/**/` - matches /path/.git/ only (because of trailing slash)
      - `/etc/*`      - matches /etc/conf.d/, /etc/X11, but not /etc/X11/fs
      - `/etc/**/*.d` - matches /etc/conf.d, /etc/X11/conf.d, etc.
      - `/etc/**/*`   - matches /etc/ itself and any file below it
      - `/etc/**/**`  - matches /etc/ itself and any file below it

:au[tocmd] [{event}] [{pat}]
    list those autocommands that match given event-pattern combination.
    {event} and {pat} can be omitted to list all autocommands.  To list any
    autocommands for specific pattern one can use * placeholder in place of
    {event}.
:au[tocmd]! [{event}] [{pat}]
    remove autocommands that match given event-pattern combination.  Syntax
    is the same as for listing above.

                                               *vifm-:bmark*
:bmark tag1 [tag2 [tag3...]]
    bookmark current directory with specified tags.
:bmark! path tag1 [tag2 [tag3...]]
    same as :bmark, but allows bookmarking specific path instead of current
    directory.  This is for use in vifmrc and for bookmarking files.

    Path can contain macros that expand to single path (%c, %C, %d, %D) or
    those that can expand to multiple paths, but contain only one (%f, %F,
    %rx).  The latter is done for convenience on using the command
    interactively.  Complex macros that include spaces (e.g. "%c:gs/ /_")
    should be escaped.

                                               *vifm-:bmarks*
:bmarks
    display all bookmarks in a menu.  See |vifm-menus-and-dialogs| for
    controls.
:bmarks [tag1 [tag2...]]
    display menu of bookmarks that include all of the specified tags.  See
    |vifm-menus-and-dialogs| for controls.

                                               *vifm-:bmgo*
:bmgo [tag1 [tag2...]]
    when there are more than one match acts exactly like :bmarks, otherwise
    navigates to single match immediately (and fails if there is no match).

                                               *vifm-:cabbrev* *vifm-:ca*
:ca[bbrev]
    display menu of command-line mode abbreviations.  See
    |vifm-menus-and-dialogs| for controls.
:ca[bbrev] lhs-prefix
    display command-line mode abbreviations which left-hand side starts with
    specified prefix.
:ca[bbrev] lhs rhs
    register new or overwrite existing abbreviation for command-line mode.
    rhs can contain spaces and any special sequences accepted in rhs of
    mappings (see |vifm-mappings|).  Abbreviations are expanded non-recursively.

                                               *vifm-:call* *vifm-:cal*
:cal[l] {function}([{expr1}, ...])
    invoke a {function} discarding its return value.

    Unlike in Vim, a call expression followed by trailing characters is not
    invoked.

                                               *vifm-:chistory* *vifm-:chi*
:chi[story]
    display menu of saved menus.  See |vifm-menus-and-dialogs| for controls,
    also see |vifm-menus-history|.

                                               *vifm-:cnoreabbrev*
                                               *vifm-:cnorea*
:cnorea[bbrev]
    display menu of command-line mode abbreviations.  See
    |vifm-menus-and-dialogs| for controls.
:cnorea[bbrev] lhs-prefix
    display command-line mode abbreviations which left-hand side starts with
    specified prefix.
:cnorea[bbrev] lhs rhs
    same as :cabbrev, but mappings in rhs are ignored during expansion.

                                               *vifm-:cd*
:cd or :cd ~ or :cd $HOME
    change to home directory.
:cd -
    go to the last visited directory.
:cd ~/dir
    change directory to ~/dir.
:cd /curr/dir /other/dir
    change directory of the current pane to /curr/dir and directory of the
    other pane to /other/dir.  Relative paths are assumed to be relative to
    directory of current view.  Command won't fail if one of directories is
    invalid.  All forms of the command accept macros.
:cd! /dir
    same as :cd /dir /dir.

                                               *vifm-:cds*
:cds[!] pattern string [flags]
    navigate to path obtained by substituting first match in current path.
    Arguments can include slashes, but starting first argument with a
    separator will activate below form of the command.  Specifying "!"
    changes directory of both panes.
    Available flags:
        i - ignore case (the |vifm-'ignorecase'| and |vifm-'smartcase'|
            options are not used)
        I - don't ignore case (the |vifm-'ignorecase'| and
            |vifm-'smartcase'| options are not used)
:cds[!]/pattern/string/[flags]
    same as above, but with |vifm-:substitute|-like syntax.  Other punctuation
    characters can be used as separators.

:c[hange]                                      *vifm-:change* *vifm-:c*
    show a dialog to alter properties of files.

                                               *vifm-:chmod*
:[range]chmod
    display file attributes (permission on *nix and properties on Windows)
    change dialog.
:[range]chmod[!] arg...                        {only for *nix}
    change permissions for files.  See `man 1 chmod` for arg format.  "!"
    means set permissions recursively.

                                               *vifm-:chown*
                                               {only for *nix}
:[range]chown
    same as |vifm-co| key in normal mode.
:[range]chown [user][:][group]
    change owner and/or group of files.  Operates on directories recursively.

                                               *vifm-:clone*
:[range]clone[!?]
    clone files in current directory.  With "?" prompts for destination file
    names in an editor.  "!" forces overwrite.  Macros are expanded.
:[range]clone[!] path
    clone files to directory specified with the path (absolute or relative to
    current directory).  Macros are expanded.
:[range]clone[!] name1 name2...
    clone files in current directory giving each next clone a corresponding
    name from the argument list.  Macros are expanded.

                                               *vifm-:colorscheme* *vifm-:colo*
:colo[rscheme]?
    print current color scheme name on the status bar.
:colo[rscheme]
    display a menu with a list of available color schemes.  You can choose
    primary color scheme here.  It is used for view if no directory specific
    colorscheme fits current path.  It's also used to set border color (except
    view titles) and colors in menus and dialogs.  See
    |vifm-menus-and-dialogs| for controls.
:colo[rscheme] color_scheme_name
    change primary color scheme to color_scheme_name.  In case of errors
    (e.g. some colors are not supported by terminal) either nothing is
    changed or color scheme is reset to builtin colors to ensure that TUI is
    left in a usable state.
:colo[rscheme] color_scheme_name directory
    associate directory with the color scheme.  The directory argument can
    be either absolute or relative path when :colorscheme command is executed
    from command line, but mandatory should be an absolute path when the
    command is executed in scripts loaded at startup (until vifm is
    completely loaded).
:colo[rscheme] color_scheme_name color_scheme_name...
    loads the first color scheme in the order given that exists and is supported
    by the terminal.  If none matches, current one remains unchanged.
    For example: >
      " use a separate color scheme for panes which are inside FUSE mounts
      execute 'colorscheme in-fuse' &fusehome

:comc[lear]                                    *vifm-:comclear* *vifm-:comc*
    remove all user defined commands.

                                               *vifm-:command* *vifm-:com*
:com[mand]
    display a menu of user commands.  See |vifm-menus-and-dialogs| for
    controls.
:com[mand] prefix
    display user defined commands that start with the prefix.
:com[mand][!] name action[ &]
    set or redefine a user command.  Use :com[mand]! to overwrite a
    previously set command of the same name.  Builtin commands can't be
    redefined.

    User commands must start with an upper or lower case letter.  Command
    name can't contain special symbols except for a single trailing
    '?' or '!'.  Numbers are allowed provided that they don't cause parsing
    ambiguity (no command name prefix that precedes a digit can match an
    existing command unless it has a digit in the same place), for example: >
      " good
      :command mp3 command
      " good
      :command mp4 command
      :command mp3! command
      :command mp4? command
      " bad
      :command mp command
      :command mp44 command
      " good
      :command mp4c command
<
    User commands are run in a shell by default (see below for syntax of other
    options).  To run a command in the background you must mark it as a
    background command by adding " &" after the command's action
    (e.g., `:com rm rm %f &`).

    User commands of all kinds have macros expanded in them.  See
    |vifm-macros| for more information.
:com[mand] name /pattern
    set search pattern.
:com[mand] name =pattern
    set local filter value.
:com[mand] name filter{:filter args}
    set file name filter (see |vifm-:filter|).  For example: >
      " display only audio files
      :command onlyaudio filter/.+\.\(mp3|wav|mp3|flac|ogg|m4a|wma|ape\)$/i
      " display everything except audio files
      :command noaudio filter!/.+\.\(mp3|wav|mp3|flac|ogg|m4a|wma|ape\)$/i
:com[mand] name :commands
    set kind of an alias for internal commands (like in a shell).  Passes
    range given to the alias to aliased command, so running :%cp after >
      :command cp :copy %a
<    equals >
      :%copy
<
                                               *vifm-:compare*
:compare [byname | bysize | bycontents |
          listall | listunique | listdups |
          ofboth | ofone |
          groupids | grouppaths |
          skipempty | withicase | withrcase |
          showidentical | showdifferent | showuniqueleft | showuniqueright]...
    compare files in one or two views according to the arguments.  The default
    is "bycontents listall ofboth grouppaths showidentical showdifferent
    showuniqueleft showuniqueright".  See |vifm-compare-views| for
    details.  Diff structure is incompatible with alternative representations,
    so values of |vifm-'lsview'| and |vifm-'millerview'| options are ignored.
:compare! (showidentical | showdifferent | showuniqueleft |
           showuniqueright)...
    this invocation form works only when compare view is active and results in
    redoing of the previous :compare with toggled state of the passed in
    options.

:cope[n]                                       *vifm-:copen* *vifm-:cope*
    reopens the last visible menu that has navigation to files by default, if
    any.  See |vifm-menus-history|.

                                               *vifm-:copy* *vifm-:co*
:[range]co[py][!?][ &]
    copy files to directory of other view.  With "?" prompts for destination
    file names in an editor.  "!" forces overwrite.
:[range]co[py][!] path[ &]
    copy files to directory specified with the path (absolute or relative to
    directory of other view).  "!" forces overwrite.
:[range]co[py][!] name1 name2...[ &]
    copy files to directory of other view giving each next file a
    corresponding name from the argument list.  "!" forces overwrite.
:[range]co[py][!?] -skip ...
    see |vifm-skip-param|.

Also see |vifm-file-copying|.

:cq[uit][!]                                    *vifm-:cquit* *vifm-:cq*
    same as |vifm-:quit|, but also aborts directory choosing via
    |vifm---choose-dir| (empties output file) and returns non-zero exit code.

                                               *vifm-:cunabbrev* *vifm-:cuna*
:cuna[bbrev] lhs
    unregister command-line mode abbreviation by its lhs.
:cuna[bbrev] rhs
    unregister command-line mode abbreviation by its rhs, so that abbreviation
    could be removed even after expansion.

                                               *vifm-:delbmarks*
:delbmarks
    remove bookmarks from current directory.
:delbmarks tag1 [tag2 [tag3...]]
    remove set of bookmarks that include all of the specified tags.
:delbmarks!
    remove all bookmarks.
:delbmarks! path1 [path2 [path3...]]
    remove bookmarks of listed paths.

:delc[ommand] user_command                     *vifm-:delcommand* *vifm-:delc*
    remove user defined command named user_command.

                                               *vifm-:delete* *vifm-:d*
:[range]d[elete][!] [reg] [count]
    delete selected or [count] files into [reg] (" by default).  "!" means
    complete removal (omitting trash).
:[range]d[elete][!] [count] &
    delete [count] files in background.  "!" means complete removal.

                                               *vifm-:delmarks* *vifm-:delm*
:delm[arks]!
    delete all marks.
:delm[arks] marks ...
    delete specified marks, each argument is treated as a set of marks.

                                               *vifm-:delsession*
:delsession name
    delete specified session if it was stored previously.  Deleting current
    session doesn't detach it.

                                               *vifm-:display* *vifm-:di*
:di[splay]
    display menu with registers content.
:di[splay] list
    display the contents of the numbered and named registers that are
    mentioned in list (for example "az to display "", "a and "z content).

:dirs                                          *vifm-:dirs*
    display directory stack in a menu.  See |vifm-menus-and-dialogs| for
    controls.

:ec[ho] [<expr>...]                            *vifm-:echo* *vifm-:ec*
    evaluate each argument as an expression and output them separated with a
    space.  See |vifm-:let| for definition of <expr>.

:[range]e[dit] [file...]                       *vifm-:edit* *vifm-:e*
    open selected or passed file(s) in editor.  Macros and environment
    variables are expanded.

:el[se]                                        *vifm-:else* *vifm-:el*
    execute commands until next matching |vifm-:endif| if all other conditions
    didn't match.  See also |vifm-:if| and |vifm-commands-and-selection|.

:elsei[f] {expr1}                              *vifm-:elseif* *vifm-:elsei*
    execute commands until next matching |vifm-:elseif|, |vifm-:else| or
    |vifm-:endif| if conditions of previous :if and :elseif branches were
    evaluated to zero.  See also |vifm-:if| and |vifm-commands-and-selection|.

:empty                                         *vifm-:empty*
    permanently remove files from all existing non-empty trash directories (see
    |vifm-trash|).  Trash directories which are specified via %r and/or %u also
    get deleted completely.  Also remove all operations from undolist that have
    no sense after :empty and remove all records about files located inside
    directories from all registers.  Removal is performed as background task
    with undetermined amount of work and can be checked via |vifm-:jobs| menu.

:en[dif]                                       *vifm-:endif* *vifm-:en*
    end conditional block.  See also |vifm-:if| and |vifm-:else|.

:exe[cute] [<expr>...]                         *vifm-:execute* *vifm-:exe*
    evaluate each argument as an expression and join results separated by a
    space to get a single string which is then executed as a command-line
    command.  See |vifm-:let| for definition of <expr>.

:exi[t][!]                                     *vifm-:exit* *vifm-:exi*
    same as |vifm-:quit|.

                                               *vifm-:file* *vifm-:f*
:f[ile][ &]
    display menu of programs set for the file type of the current file.  " &"
    forces running associated program in background.  See
    |vifm-menus-and-dialogs| for controls.
:f[ile] arg[ &]
    run associated command that begins with the arg skipping opening menu.  " &"
    forces running associated program in background.

                                               *vifm-:filetype* *vifm-:filet*
:filet[ype] pattern-list [{ descr }]def_program[ &],[{ descr }]prog2[ &],...
    associate given program list to each of the patterns.  Associated
    program (command) is used by handlers of l and Enter keys (and also in
    the :file menu).  If you need to insert comma into command just double
    it (",,").  Space followed by an ampersand as two last characters
    means running command in background.  Optional description can be given to
    each command to ease understanding of what command does in the :file menu.
    The rest of the programs for an association is inspected if the default
    one isn't found.  When program entry doesn't contain any of vifm macros,
    name of current file is appended as if program entry ended with %c macro
    on *nix and %"c on Windows.  On Windows path to executables containing
    spaces can (and should be for correct work with such paths) be double
    quoted.  See |vifm-patterns| for pattern definition and |vifm-selection| for
    how selection is handled.  See also |vifm-fuse|.
    Example for zip archives and several actions: >

    filetype *.zip,*.jar,*.war,*.ear
           \ {Mount with fuse-zip}
           \ FUSE_MOUNT|fuse-zip %SOURCE_FILE %DESTINATION_DIR,
           \ {View contents}
           \ zip -sf %c | less,
           \ {Extract here}
           \ tar -xf %c,
<
    Note that on OS X when `open` is used to call an app, vifm is unable to
    check whether that app is actually available.  So if automatic skipping
    of programs that aren't there is desirable, `open` should be replaced
    with an actual command.

:filet[ype] filename
    list (in menu mode) currently registered patterns that match specified
    file name.  Same as ":filextype filename".

                                               *vifm-:filextype* *vifm-:filex*
:filex[type] pattern-list [{ description }] def_program,program2,...
    same as :filetype, but this command is ignored if not running in X.  In
    X :filextype is equal to :filetype.  See |vifm-patterns| for pattern
    definition and |vifm-selection| for how selection is handled.  See also
    |vifm-fuse|.

    For example, consider the following settings (the order might seem
    strange, but it's for the demonstration purpose): >

    filetype *.html,*.htm
            \ {View in lynx}
            \ lynx
    filextype *.html,*.htm
            \ {Open with dwb}
            \ dwb %f %i &,
    filetype *.html,*.htm
            \ {View in links}
            \ links
    filextype *.html,*.htm
            \ {Open with firefox}
            \ firefox %f &,
            \ {Open with uzbl}
            \ uzbl-browser %f %i &,
<
    If you're using vifm inside a terminal emulator that is running in
    graphical environment (when X is used on *nix; always on Windows), vifm
    attempts to run application in this order:

    1. lynx
    2. dwb
    3. links
    4. firefox
    5. uzbl

    If there is no graphical environment (checked by presence of non-empty
    $DISPLAY or $WAYLAND_DISPLAY environment variable on *nix; never happens
    on Windows), the list will look like:

    1. lynx
    2. links

    Just as if all :filextype commands were not there.

    The purpose of such differentiation is to allow comfortable use of vifm
    with same settings in desktop environment/through remote connection (SSH)/
    in native console.

    Note that on OS X $DISPLAY isn't defined unless you define it, so
    :filextype should be used only if you set $DISPLAY in some way.

:filext[ype] filename
    list (in menu mode) currently registered patterns that match specified
    file name.  Same as ":filetype filename".

                                               *vifm-:fileviewer* *vifm-:filev*
:filev[iewer] pattern-list command1,command2,...
    register specified list of commands as viewers for each of the patterns.
    Viewer is a command which output is captured and displayed in one of the
    panes of vifm after pressing |vifm-e| or running |vifm-:view| command.
    When the command doesn't contain any of vifm macros, name of current file
    is appended as if command ended with |vifm-%c| macro.  Comma escaping and
    missing commands processing rules as for |vifm-:filetype| apply to this
    command.  See |vifm-patterns| for pattern definition.  Supports
    |vifm-lua-handlers|.

    Example for zip archives: >

     fileviewer *.zip,*.jar,*.war,*.ear zip -sf %c, echo "No zip to preview:"
<
:filev[iewer] filename
    list (in menu mode) currently registered patterns that match specified
    filename.

                                               *vifm-:filter*
:filter[!] {pattern}
    filter files matching the pattern out of directory listings.  '!'
    controls state of filter inversion after updating filter value
    (see |vifm-cpo-f|).  Filter is matched case sensitively on *nix and
    case insensitively on Windows.  See |vifm-filters| and |vifm-patterns|.

    Example: >
        " filter all files ending in .o from the filelist.
        :filter /\.o$/

:filter[!] {empty-pattern}
    same as above, but use last search pattern as pattern value.

    Example: >
        :filter //I

:filter
    reset filter (set it to an empty string) and show all files.
:filter!
    same as |vifm-:invert|.
:filter?
    display information on local, name and auto filters.

                                               *vifm-:find* *vifm-:fin*
:[range]fin[d] pattern
    display results of find command in the menu.  Searches among selected
    files if any and no range given.  Macros are accepted.  By default the
    command relies on the external "find" utility, which can be customized
    by altering value of the |vifm-'findprg'| option.  See
    |vifm-menus-and-dialogs| for controls.
:[range]fin[d] -opt...
    same as :find above, but user defines all find arguments.  Searches among
    selected files if any and no range given.
:[range]fin[d] path -opt...
    same as :find above, but user defines all find arguments.  Ignores
    selection and range.
:[range]fin[d]
    repeat last :find command.

:fini[sh]                                      *vifm-:finish* *vifm-:fini*
    stop script sourcing.  Can only be used in a vifm script file.  This is a
    quick way to skip processing of the rest of the file without even parsing
    it.

:go[to] path                                   *vifm-:goto* *vifm-:go*
    change directory if necessary and put specified path under the cursor.
    The path should be existing non-root path.  Macros and environment
    variables are expanded.

                                               *vifm-:grep* *vifm-:gr*
:[range]gr[ep][!] pattern
    display results of "grep" command in the menu.  Add "!" to request
    inversion of search (look for lines that do not match pattern).  Searches
    among selected files if any and no range given.  Ignores binary files by
    default.  By default the command relies on the external "grep" utility,
    which can be customized by altering value of the |vifm-'grepprg'| option.
    See |vifm-menus-and-dialogs| for controls.
:[range]gr[ep][!] -opt...
    same as :grep above, but user defines all grep arguments, which are not
    escaped.  Searches among selected files if any.
:[range]gr[ep][!]
    repeat last :grep command.  "!" of this command inverts "!" in repeated
    command.

                                               *vifm-:help* *vifm-:h*
:h[elp]
    display documentation in editor.
:h[elp] argument
    same as using ':h argument' in vim.  Use vifm-<something> to get help on
    vifm (tab completion works and matches in the middle of the string as
    well).  This form of the command doesn't work when |vifm-'vimhelp'| option
    is off.

:hideui                                        *vifm-:hideui*
    hide interface to show previous commands' output.

                                               *vifm-:highlight* *vifm-:hi*
:hi[ghlight]
    display information about all highlight groups active at the moment.
:hi[ghlight] clear
    reset all highlighting to builtin defaults and removed all
    filename-specific rules.
:hi[ghlight] clear ( {pat1,pat2,...} | /regexp/ )
    remove specified rule.
:hi[ghlight] group-name | column:name | {pat1,pat2,...} | /regexp/
    display information on given highlight group or file name pattern of color
    scheme used in the active view.
:hi[ghlight] ( group-name | column:name | {pat1,pat2,...} | /regexp/[iI] )
             cterm=style | ctermfg=color | ctermbg=color |
             gui=style | guifg=color | guibg=color
    set style (cterm, gui), foreground (ctermfg, guifg) and/or
    background (ctermbg, guibg) parameters of highlight group or file name
    pattern for color scheme used in the active view.

Group names, style values and color names are case insensitive.  Note that this
doesn't include column names as that would make builtin and custom columns
indistinguishable.

Available group-name values:
 - Win - color of all windows (views, dialogs, menus) and default color for
         their content (e.g. regular files in views)
 - AuxWin - color of auxiliary areas of windows
 - OtherWin - color of inactive pane
 - Border - color of vertical parts of the border
 - TabLine - tab line color (for |vifm-'tabscope'| set to "global")
 - TabLineSel - color of the tip of selected tab (regardless of
                |vifm-'tabscope'|)
 - TopLine - top line color of the other pane
 - TopLineSel - top line color of the current pane
 - CmdLine - the command line/status bar color
 - ErrorMsg - color of error messages in the status bar
 - StatusLine - color of the line above the status bar
 - JobLine - color of job line that appears above the status line
 - WildBox - color of the wild menu
 - WildMenu - color of the selected wild menu item
 - SuggestBox - color of key suggestion box
 - CurrLine - line at cursor position in active view
 - OtherLine - line at cursor position in inactive view
 - OddLine - color of every second entry line in a pane
 - LineNr - line number column of views
 - Selected - color of selected files
 - Directory - color of directories
 - Link - color of symbolic links in the views
 - BrokenLink - color of broken symbolic links
 - HardLink - color of regular files with more than one hard link
 - Socket - color of sockets
 - Device - color of block and character devices
 - Executable - color of executable files
 - Fifo - color of fifo pipes
 - CmpMismatch - color of mismatched files in side-by-side comparison by paths
 - CmpUnmatched - comparison file entry that has no pair in the other pane
 - CmpBlank - entry placeholder in a compare view, paired with CmpUnmatched
 - User1..User20 - 20 colors which can be used via %* |vifm-'statusline'|
   macro

Column names match names of columns of |vifm-'viewcolumns'| option, which in
turn are based on values of |vifm-'sort'| and custom columns added from Lua.
Regardless of the source, columns are specified as "column:{name}", for
example: >

  highlight column:fileext ctermbg=red

Available style values (some of them can be combined):
 - bold
 - underline
 - reverse or inverse
 - standout
 - italic (on unsupported systems becomes reverse)
 - combine - add attributes of current group to attributes of the parent in
             group hierarchy (see below) instead of replacing them
 - none

Available colors:
 - -1 or default or none - transparent
 - black   and lightblack
 - red     and lightred
 - green   and lightgreen
 - yellow  and lightyellow
 - blue    and lightblue
 - magenta and lightmagenta
 - cyan    and lightcyan
 - white   and lightwhite
 - 0-255 - corresponding colors from 256-color palette
           (for ctermfg and ctermbg)
 - #rrggbb - direct ("gui", "true", 24-bit) color in hex-notation, each of
             the three components are in the range 0x00 to 0xff
             (for guifg and guibg)

Light versions of colors are regular colors with bold attribute set
automatically in terminals that have less than 16 colors.  So order of arguments
of :highlight command is important and it's better to put "cterm" in front of
others to prevent it from overwriting attributes set by "ctermfg" or "ctermbg"
arguments.

For convenience of color scheme authors xterm-like names for 256 color palette
is also supported.  The mapping is taken from
http://vim.wikia.com/wiki/Xterm256_color_names_for_console_Vim
Duplicated entries were altered by adding an underscore followed by numerical
suffix.

  0 Black                  86 Aquamarine1           172 Orange3
  1 Red                    87 DarkSlateGray2        173 LightSalmon3_2
  2 Green                  88 DarkRed_2             174 LightPink3
  3 Yellow                 89 DeepPink4_2           175 Pink3
  4 Blue                   90 DarkMagenta           176 Plum3
  5 Magenta                91 DarkMagenta_2         177 Violet
  6 Cyan                   92 DarkViolet            178 Gold3_2
  7 White                  93 Purple                179 LightGoldenrod3
  8 LightBlack             94 Orange4_2             180 Tan
  9 LightRed               95 LightPink4            181 MistyRose3
 10 LightGreen             96 Plum4                 182 Thistle3
 11 LightYellow            97 MediumPurple3         183 Plum2
 12 LightBlue              98 MediumPurple3_2       184 Yellow3_2
 13 LightMagenta           99 SlateBlue1            185 Khaki3
 14 LightCyan             100 Yellow4               186 LightGoldenrod2
 15 LightWhite            101 Wheat4                187 LightYellow3
 16 Grey0                 102 Grey53                188 Grey84
 17 NavyBlue              103 LightSlateGrey        189 LightSteelBlue1
 18 DarkBlue              104 MediumPurple          190 Yellow2
 19 Blue3                 105 LightSlateBlue        191 DarkOliveGreen1
 20 Blue3_2               106 Yellow4_2             192 DarkOliveGreen1_2
 21 Blue1                 107 DarkOliveGreen3       193 DarkSeaGreen1_2
 22 DarkGreen             108 DarkSeaGreen          194 Honeydew2
 23 DeepSkyBlue4          109 LightSkyBlue3         195 LightCyan1
 24 DeepSkyBlue4_2        110 LightSkyBlue3_2       196 Red1
 25 DeepSkyBlue4_3        111 SkyBlue2              197 DeepPink2
 26 DodgerBlue3           112 Chartreuse2_2         198 DeepPink1
 27 DodgerBlue2           113 DarkOliveGreen3_2     199 DeepPink1_2
 28 Green4                114 PaleGreen3_2          200 Magenta2_2
 29 SpringGreen4          115 DarkSeaGreen3         201 Magenta1
 30 Turquoise4            116 DarkSlateGray3        202 OrangeRed1
 31 DeepSkyBlue3          117 SkyBlue1              203 IndianRed1
 32 DeepSkyBlue3_2        118 Chartreuse1           204 IndianRed1_2
 33 DodgerBlue1           119 LightGreen_2          205 HotPink
 34 Green3                120 LightGreen_3          206 HotPink_2
 35 SpringGreen3          121 PaleGreen1            207 MediumOrchid1_2
 36 DarkCyan              122 Aquamarine1_2         208 DarkOrange
 37 LightSeaGreen         123 DarkSlateGray1        209 Salmon1
 38 DeepSkyBlue2          124 Red3                  210 LightCoral
 39 DeepSkyBlue1          125 DeepPink4_3           211 PaleVioletRed1
 40 Green3_2              126 MediumVioletRed       212 Orchid2
 41 SpringGreen3_2        127 Magenta3              213 Orchid1
 42 SpringGreen2          128 DarkViolet_2          214 Orange1
 43 Cyan3                 129 Purple_2              215 SandyBrown
 44 DarkTurquoise         130 DarkOrange3           216 LightSalmon1
 45 Turquoise2            131 IndianRed             217 LightPink1
 46 Green1                132 HotPink3              218 Pink1
 47 SpringGreen2_2        133 MediumOrchid3         219 Plum1
 48 SpringGreen1          134 MediumOrchid          220 Gold1
 49 MediumSpringGreen     135 MediumPurple2         221 LightGoldenrod2_2
 50 Cyan2                 136 DarkGoldenrod         222 LightGoldenrod2_3
 51 Cyan1                 137 LightSalmon3          223 NavajoWhite1
 52 DarkRed               138 RosyBrown             224 MistyRose1
 53 DeepPink4             139 Grey63                225 Thistle1
 54 Purple4               140 MediumPurple2_2       226 Yellow1
 55 Purple4_2             141 MediumPurple1         227 LightGoldenrod1
 56 Purple3               142 Gold3                 228 Khaki1
 57 BlueViolet            143 DarkKhaki             229 Wheat1
 58 Orange4               144 NavajoWhite3          230 Cornsilk1
 59 Grey37                145 Grey69                231 Grey100
 60 MediumPurple4         146 LightSteelBlue3       232 Grey3
 61 SlateBlue3            147 LightSteelBlue        233 Grey7
 62 SlateBlue3_2          148 Yellow3               234 Grey11
 63 RoyalBlue1            149 DarkOliveGreen3_3     235 Grey15
 64 Chartreuse4           150 DarkSeaGreen3_2       236 Grey19
 65 DarkSeaGreen4         151 DarkSeaGreen2         237 Grey23
 66 PaleTurquoise4        152 LightCyan3            238 Grey27
 67 SteelBlue             153 LightSkyBlue1         239 Grey30
 68 SteelBlue3            154 GreenYellow           240 Grey35
 69 CornflowerBlue        155 DarkOliveGreen2       241 Grey39
 70 Chartreuse3           156 PaleGreen1_2          242 Grey42
 71 DarkSeaGreen4_2       157 DarkSeaGreen2_2       243 Grey46
 72 CadetBlue             158 DarkSeaGreen1         244 Grey50
 73 CadetBlue_2           159 PaleTurquoise1        245 Grey54
 74 SkyBlue3              160 Red3_2                246 Grey58
 75 SteelBlue1            161 DeepPink3             247 Grey62
 76 Chartreuse3_2         162 DeepPink3_2           248 Grey66
 77 PaleGreen3            163 Magenta3_2            249 Grey70
 78 SeaGreen3             164 Magenta3_3            250 Grey74
 79 Aquamarine3           165 Magenta2              251 Grey78
 80 MediumTurquoise       166 DarkOrange3_2         252 Grey82
 81 SteelBlue1_2          167 IndianRed_2           253 Grey85
 82 Chartreuse2           168 HotPink3_2            254 Grey89
 83 SeaGreen2             169 HotPink2              255 Grey93
 84 SeaGreen1             170 Orchid
 85 SeaGreen1_2           171 MediumOrchid1

There are two colors (foreground and background) and only one bold attribute.
Thus single bold attribute affects both colors when "reverse" attribute is used
in vifm run inside terminal emulator.  At the same time linux native console can
handle boldness of foreground and background colors independently, but for
consistency with terminal emulators this is available only implicitly by using
light versions of colors.  This behaviour might be changed in the future.

Although vifm supports 256 colors in a sense they are supported by UI drawing
library, whether you will be able to use all of them highly depends on your
terminal.  To set up terminal properly, make sure that $TERM in the
environment you run vifm is set to name of 256-color terminal (on *nixes it can
also be set via X resources), e.g. xterm-256color.  One can find list of
available terminal names by listing /usr/lib/terminfo/.  Number of colors
supported by terminal with current settings can be checked via "tput colors"
command.

In order to use 24-bit colors one needs a terminal that supports them,
corresponding terminfo record (probably ends in "-direct" like in
"xterm-direct") and $TERM pointing to it.  When vifm detects direct color
support "cterm*" values are ignored for groups which have at least one of
"gui*" values set, otherwise they are used after translating via a builtin
palette.

Here is the hierarchy of highlight groups, which you need to know for using
transparency:
  JobLine
  SuggestBox
  StatusLine
    WildBox
      WildMenu
    User1..User20
  Border
  CmdLine
    ErrorMsg
  Win
    OtherWin
      AuxWin
        OddLine
          Column highlights
            File name specific highlights
              Directory
              Link
              BrokenLink
              HardLink
              Socket
              Device
              Fifo
              Executable
                CmpMismatch
                CmpUnmatched
                CmpBlank
                  Selected
                    CurrLine
                      LineNr (in active pane)
                    OtherLine
                      LineNr (in inactive pane)
  TopLine
    TopLineSel
      TabLineSel (for pane tabs)
        User1..User20
  TabLine
    TabLineSel
      User1..User20

"none" means default terminal color for highlight groups at the first level
of the hierarchy and transparency for all others.

Here file name specific highlights mean those configured via globs ({}) or
regular expressions (//).  At most one of them is applied per file entry, namely
the first that matches file name, hence order of :highlight commands might be
important in certain cases.

:histnext                                      *vifm-:histnext*
    same as <c-i>.  The main use case for this command is to work around the
    common pain point of <tab> and <c-i> being the same ASCII character: one
    could alter the terminal emulator settings to emit, for example, the `F1`
    keycode when Ctrl-I is pressed, then `:noremap <f1> :histnext<cr>` in vifm,
    add "t" flag to the |vifm-'cpoptions'|, and thus have both <c-i> and <tab>
    working as expected.

                                               *vifm-:history* *vifm-:his*
:his[tory]
    display a menu with list of visited directories.  See
    |vifm-menus-and-dialogs| for controls.
:his[tory] x
    where x can be:
      d[ir]     or .  show directory history.
      c[md]     or :  show command line history.
      s[earch]  or /  show search history and search forward on l key.
      f[search] or /  show search history and search forward on l key.
      b[search] or ?  show search history and search backward on l key.
      i[nput]   or @  show prompt history (e.g. on one file renaming).
      fi[lter]  or =  show local filter history (see |vifm-=|).
      e[xprreg]       show expression register history (see |vifm-c_CTRL-R_=|).
      mc[md]          show command-line history of menus.
    See |vifm-menus-and-dialogs| for controls.

:histprev                                      *vifm-:histprev*
    same as <c-o>.

:if {expr1}                                    *vifm-:if*
    start conditional block.  Commands are executed until next matching
    |vifm-:elseif|, |vifm-:else| or |vifm-:endif| command if {expr1} evaluates
    to non-zero, otherwise they are ignored.  An error during evaluation of
    {expr1} results in not taking any conditional branches (not even an
    else-branch).  See also |vifm-commands-and-selection|.

    Example: >
      if $TERM == 'screen.linux'
          highlight CurrLine ctermfg=lightwhite ctermbg=lightblack
      elseif $TERM == 'tmux'
          highlight CurrLine cterm=reverse ctermfg=black ctermbg=white
      else
          highlight CurrLine cterm=bold,reverse ctermfg=black ctermbg=white
      endif
<
                                               *vifm-:invert*
:invert [f]
    invert file name filter.
:invert? [f]
    display current filter state.
:invert s
    invert selection.  See also |vifm-commands-and-selection|.
:invert o
    invert sorting order of the primary sorting key.
:invert? o
    display sorting order of the primary sorting key.

:jobs                                          *vifm-:jobs*
    display menu of current backgrounded processes.  See
    |vifm-menus-and-dialogs| for controls.

:keepsel [command...]                          *vifm-:keepsel*
    preserve selection during some :command by default.  Note that this
    doesn't save and restore selection to preserve it no matter what, but
    precludes its clearing at the end of a command and thus won't help if
    selection is cleared explicitly during operation.

    Example: >
      :keepsel view
<
                                               *vifm-:let*
:let $ENV_VAR = <expr>
    set an environment variable.  Note: setting environment variable to an
    empty string on Windows removes it.
:let $ENV_VAR .= <expr>
    append value to environment variable.
:let &[l:|g:]opt = <expr>
    sets option value.
:let &[l:|g:]opt .= <expr>
    append value to string option.
:let &[l:|g:]opt += <expr>
    increasing option value, adding sub-values.
:let &[l:|g:]opt -= <expr>
    decreasing option value, removing sub-values.

Where <expr> could be a single-quoted string, double-quoted string, an
environment variable, function call or a concatanation of any of them in any
order using the '.' operator.  Any whitespace is ignored.

                                               *vifm-:locate*
:locate filename
    use "locate" command to create a menu of file names.  Selecting a file
    from the menu reloads current file list in vifm to navigate to the file.
    By default the command relies on the external "locate" utility (it's
    assumed that its database is already built), which can be customized by
    altering value of the |vifm-'locateprg'| option.  See
    |vifm-menus-and-dialogs| for controls.
:locate
    repeat last :locate command.

:ls                                            *vifm-:ls*
    list windows of active terminal multiplexer (only when terminal
    multiplexer is used).  This is achieved by issuing proper command for
    active terminal multiplexer, thus the list is not handled by vifm.

:lstrash                                       *vifm-:lstrash*
    display a menu with list of files in trash.  Each element of the list is
    original path of a deleted file, thus the list can contain duplicates.
    See |vifm-menus-and-dialogs| for controls.

:[range]ma[rk][?] x [/full/dir/path [filename]]      *vifm-:mark* *vifm-:ma*
    set mark x (a-zA-Z0-9) at /full/dir/path and filename.  By default current
    file in current directory is used.  If no filename was given and
    /full/dir/path is current directory, then the last file of the [range] is
    used.  Question mark stops the command from overwriting an existing mark.
    Macros and environment variables are expanded.

                                               *vifm-:marks*
:marks
    display menu of all marks.  See |vifm-menus-and-dialogs| for controls.
:marks list ...
    display the contents of the marks that are mentioned in list.

                                               *vifm-:media*
:media                                         {only for *nix}
    display media management menu.  See |vifm-menus-and-dialogs| for
    controls.  See also |vifm-'mediaprg'| option.

:mes[sages]                                    *vifm-:messages* *vifm-:mes*
    display previously given status bar messages (up to 50).

:[line]mkdir[!] dir...                         *vifm-:mkdir*
    create directories at specified paths.  The [line] can be used to pick
    node in a tree-view.  "!" means make parent directories
    as needed.  Macros are expanded.

                                               *vifm-:move* *vifm-:m*
:[range]m[ove][!?][ &]
    move files to directory of other view.  With "?" prompts for destination
    file names in an editor.  "!" forces overwrite.
:[range]m[ove][!] path[ &]
    move files to directory specified with the path (absolute or relative to
    directory of other view).  "!" forces overwrite.
:[range]m[ove][!] name1 name2...[ &]
    move files to directory of other view giving each next file a
    corresponding name from the argument list.  "!" forces overwrite.
:[range]m[ove][!?] -skip ...
    see |vifm-skip-param|.

:noh[lsearch]                                  *vifm-:nohlsearch* *vifm-:noh*
    clear selection in current pane.

:norm[al][!] commands                          *vifm-:normal* *vifm-:norm*
    execute normal mode commands.  If "!" is used, user defined mappings are
    ignored.  Unfinished last command is aborted as if <esc> or <c-c> was
    typed.  A ":" should be completed as well.  Commands can't start with a
    space, so put a count of 1 (one) before it.

:on[ly]                                        *vifm-:only* *vifm-:on*
    switch to a one window view.

:[range]o[pen]                                 *vifm-:o* *vifm-:open*
    open current file, selection or files in the range as if |vifm-Enter| was
    pressed.

                                               *vifm-:plugin*
:plugin load
    loads all plugins.  To be used in configuration file to manually load
    plugins at an earlier point.  The plugins can be loaded only once,
    additional calls will do nothing.
:plugin blacklist {plugin}
    adds {plugin} to the list of plugins to be ignored.
:plugin whitelist {plugin}
    adds {plugin} to the list of plugins to be loaded while ignoring all
    other plugins.  This list should normally be empty.

:plugins                                       *vifm-:plugins*
    open plugins menu.  See |vifm-menus-and-dialogs| for controls.

:popd                                          *vifm-:popd*
    remove pane directories from stack.

                                               *vifm-:pushd*
:pushd[!] /curr/dir [/other/dir]
    add pane directories to stack and process arguments like :cd command.
:pushd
    exchange top two items of the directory stack.

:[line]pu[t][!] [reg] [ &]                     *vifm-:put* *vifm-:pu*
    put files from specified register (" by default) into current directory.
    The [line] can be used to pick node in a tree-view.  "!" moves files
    from their original location instead of copying them.  During this
    operation no confirmation dialogs will be shown, all checks are performed
    beforehand.

:pw[d]                                         *vifm-:pwd* *vifm-:pw*
    display the present working directory.

:qa[ll]!                                       *vifm-:qall* *vifm-:qa*
    exit vifm (add ! to skip saving changes and checking for active
    backgrounded commands).

:q[uit][!]                                     *vifm-:quit* *vifm-:q*
    if there is more than one tab, close the current one, otherwise exit
    vifm (add ! to skip saving state and checking for active backgrounded
    commands).

:redr[aw]                                      *vifm-:redraw* *vifm-:redr*
    redraw the screen immediately.

                                               *vifm-:regedit* *vifm-:rege*
:rege[dit] [{reg}]
    edit register contents using external editor (see |vifm-'vicmd'|).
    If {reg} is omitted, unnamed register will be edited by default.
    Edited paths are normalized (no extra `.`, `..`, `/`, etc.) and all
    relative paths are treated as starting in the directory of the current
    view.

                                               *vifm-:registers* *vifm-:reg*
:reg[isters]
    display menu with registers content.
:reg[isters] list
    display the contents of the numbered and named registers that are
    mentioned in list (for example "az to display "", "a and "z content).

:regular                                       *vifm-:regular*
    switch to regular view leaving custom view.

                                               *vifm-:rename*
:[range]rename[!]
    rename files by editing their names in an editor.  "!" renames files
    recursively in subdirectories.  See |vifm-ext-rename|.
:[range]rename name1 name2...
    rename each of selected files to a corresponding name.

                                               *vifm-:restart*
:restart
    free a lot of things (histories, commands, etc.), reread vifminfo, vifmrc
    and session files and run startup commands passed in the argument list,
    thus losing all unsaved changes (e.g. recent history or keys mapped after
    starting this instance).  Session that wasn't yet stored gets reset.

    While many things get reset, some basic UI state and current locations
    are preserved, including tabs.
:restart full
    variation of :restart that makes no attempt to preserve anything.

:[range]restore                                *vifm-:restore*
    restore file from |vifm-trash| directory, doesn't work outside one of trash
    directories.

                                               *vifm-:rlink*
:[range]rlink[!?]
    create relative symbolic links to files in directory of other view.  With
    "?" prompts for destination file names in an editor. "!" forces overwrite.
:[range]rlink[!] path
    create relative symbolic links of files in directory specified with the
    path (absolute or relative to directory of other view).  "!" forces
    overwrite.
:[range]rlink[!] name1 name2...
    create relative symbolic links of files in directory of other view giving
    each next link a corresponding name from the argument list.  "!" forces
    overwrite.
:[range]rlink[!?] -skip ...
    see |vifm-skip-param|.

                                               *vifm-:screen*
:screen
    toggle whether to use the terminal multiplexer or not.  A terminal
    multiplexer uses pseudo terminals to allow multiple windows to be used in
    the console or in a single xterm.  Starting vifm from terminal multiplexer
    with appropriate support turned on causes vifm to open a new terminal
    multiplexer window for each new file edited or program launched from vifm.
    This requires screen version 3.9.9 or newer for the screen -X argument or
    tmux (1.8 version or newer is recommended).
:screen!
    enable integration with terminal multiplexers.
:screen?
    display whether integration with terminal multiplexers is enabled.

Note: the command is called screen for historical reasons (when tmux wasn't
yet supported) and might be changed in future releases, or get an alias.

                                               *vifm-:select*
:[range]select
    select files in the given range (current file if no range is given).
:select {pattern}
    select files that match specified pattern.  Possible {pattern} forms are
    described in |vifm-patterns|.  Trailing slash for directories is taken
    into account, so `:select! */ | invert s` selects only files.
:select //[iI]
    same as item above, but reuses last search pattern.
:select !{external command}
    select files from the list supplied by external command.  Files are
    matched by full paths, relative paths are converted to absolute ones
    beforehand.
:[range]select! [{pattern}|!{external command}]
    same as above, but resets previously selected items before proceeding.

                                               *vifm-:session*
:session?
    print name of the current session.
:session
    detach current session without saving it.  Resets |vifm-v:session|.
:session name
    create or load and switch to a session with the specified name.  Name
    can't contain slashes.  Session active at the moment is saved before the
    switch.  Session is also automatically saved when quitting the
    application in usual ways.  Sets |vifm-v:session|.
:session -
    switch to a previous session if it still exists (wasn't removed or
    detached from without saving).

                                               *vifm-:set* *vifm-:se*
:se[t]
    display all options that differ from their default value.
:se[t] all
    display all options.
:se[t] opt1=val1 opt2='val2' opt3="val3" ...
    sets given options.  For |vifm-local-options| both values are set.
    You can use the following syntax:
     - for all options - option, option? and option&
     - for boolean options - nooption, invoption and option!
     - for integer options - option=x, option+=x and option-=x
     - for string options - option=x and option+=x
     - for string list options - option=x, option+=x, option-=x and option^=x
     - for enumeration options - option=x, option+=x and option-=x
     - for set options - option=x, option+=x, option\-=x and option^=x
     - for charset options - option=x, option+=x, option-=x and option^=x
    the meaning:
     - option - turn option on (for boolean) or print its value (for all
         others)
     - nooption - turn option off
     - invoption - invert option state
     - option! - invert option state
     - option? - print option value
     - option& - reset option to its default value
     - option=x or option:x - set option to x
     - option+=x - add/append x to option
     - option-=x - remove (or subtract) x from option
     - option^=x - toggle x presence among values of the option

    Option name can be prepended and appended by any number of whitespace
    characters.

                                               *vifm-:setglobal* *vifm-:setg*
:setg[lobal]
    display all global options that differ from their default value.
:setg[lobal] all
    display all global options.
:setg[lobal] opt1=val1 opt2='val2' opt3="val3" ...
    same as |vifm-:set|, but changes/prints only global options or global
    values of local options.  Changes to the latter might be not visible until
    directory is changed.

                                               *vifm-:setlocal* *vifm-:setl*
:setl[ocal]
    display all local options that differ from their default value.
:setl[ocal] all
    display all local options.
:setl[ocal] opt1=val1 opt2='val2' opt3="val3" ...
    same as |vifm-:set|, but changes/prints only local values of local
    options.

:sh[ell][!]                                    *vifm-:shell* *vifm-:sh*
    start a shell in current directory.  "!" suppresses spawning dedicated
    window of terminal multiplexer for a shell.  To make vifm adaptive to
    environment it uses $SHELL if it's defined, otherwise |vifm-'shell'|
    value is used.

:[count]siblnext[!]                                   *vifm-:siblnext*
    change directory to [count]th next sibling directory of current path
    using value of global sort option of current pane.  "!" enables wrapping.

    For example, say, you're at `/boot` and root listing starts like this: >
     bin/
     boot/
     dev/
     ...
<    Issuing :siblnext will navigate to `/dev`.

:[count]siblprev[!]                                   *vifm-:siblprev*
    same as :siblnext, but in the opposite direction.

:sor[t]                                        *vifm-:sort* *vifm-:sor*
    display dialog with different sorting methods, where one can select
    the primary sorting key.  When |vifm-'viewcolumns'| options is empty and
    |vifm-'lsview'| is off, changing primary sorting key also affects view
    look (in particular the second column of the view is changed).
    See |vifm-menus-and-dialogs| for controls.

:so[urce] file                                 *vifm-:source* *vifm-:so*
    read command-line commands from the file.

                                               *vifm-:split* *vifm-:sp*
:sp[lit]
    switch to a two window horizontal view.
:sp[lit]!
    toggle horizontal window splitting.
:sp[lit] path
    split window horizontally to show both file directories.  Also changes
    other pane to the path (absolute or relative to current directory of
    active pane).

                                               *vifm-:stop* *vifm-:st*
:st[op]
    suspend vifm (same as pressing Ctrl-Z).  Does nothing if this instance
    isn't running in a shell.  The command exists to allow mapping to the
    action of Ctrl-Z.

                                               *vifm-:substitute* *vifm-:s*
:[range]s[ubstitute]/pattern/string/[flags]
    for each file in range replace a match of pattern with string.  String
    can contain \0...\9 to link to capture groups (0 - all match, 1 - first
    group, etc.).  Pattern is stored in the search history.
    Available flags:
        i - ignore case (the |vifm-'ignorecase'| and |vifm-'smartcase'|
            options are not used)
        I - don't ignore case (the |vifm-'ignorecase'| and
            |vifm-'smartcase'| options are not used)
        g - substitute all matches in each file name (each g toggles this)
:[range]s[ubstitute]/pattern
    substitute pattern with an empty string.
:[range]s[ubstitute]//string/[flags]
    use last pattern from search history.
:[range]s[ubstitute]
    repeat previous substitution command.

                                               *vifm-:sync*
:sync [relative path]
    change the other pane to the current pane directory or to some path
    relative to the current directory.  Using of macros is allowed.
:sync!
    change the other pane to the current pane directory and synchronize
    cursor position.  If current pane displays custom list of files, position
    before entering it is used (current one might not make any sense).
:sync! [location | cursorpos | localopts | filters | filelist | tree | all]...
    change enumerated properties of the other pane to match corresponding
    properties of the current pane.  Arguments have the following meanings:
     - location - current directory of the pane;
     - cursorpos - cursor position (doesn't make sense without "location");
     - localopts - all local options;
     - filters - all filters;
     - filelist - list of files for custom view (implies "location");
     - tree - tree structure for tree view (implies "location");
     - all - all of the above.

:tabc[lose]                                    *vifm-:tabclose* *vifm-:tabc*
    close current tab, unless it's the only one open at current scope.

:tabm[ove] [N]                                 *vifm-:tabmove* *vifm-:tabm*
    without the argument or with `$` as the argument, current tab becomes
    the last tab.  With the argument, current tab is moved after the tab
    with the specified number.  Argument of `0` moves current tab to the
    first position.

:tabname [name]                                *vifm-:tabname*
    set, update or reset (when no argument is provided) name of the current
    tab.

:tabnew [path]                                 *vifm-:tabnew*
    create new tab.  Accepts optional path for the new tab.  Macros and
    environment variables are expanded.

                                               *vifm-:tabnext* *vifm-:tabn*
:tabn[ext]
    switch to the next tab (wrapping around).
:tabn[ext] {n}
    go to the tab number {n}.  Tab numeration starts with 1.

                                               *vifm-:tabonly* *vifm-:tabo*
:tabo[nly]
    close all tabs but the current one.  Closes pane tabs only at the active
    side.

                                               *vifm-:tabprevious* *vifm-:tabp*
:tabp[revious]
    switch to the previous tab (wrapping around).
:tabp[revious] {n}
    go to the {n}-th previous tab.  Note that |vifm-:tabnext| handles its
    argument differently.

:[line]touch file...                           *vifm-:touch*
    create files at specified paths.  Aborts on errors.  Doesn't update time
    of existing files.  The [line] can be used to pick node in a tree-view.
    Macros are expanded.

:[range]tr/pattern/string/                     *vifm-:tr*
    for each file in range transliterate the characters which appear in
    pattern to the corresponding character in string.  When string is shorter
    than pattern, it's padded with its last character.

                                               *vifm-:trashes*
:trashes
    list all valid trash directories in a menu.  Only non-empty and writable
    trash directories are shown.  This is exactly the list of directories that
    are cleared when |vifm-:empty| command is executed.
:trashes?
    same as :trashes, but also displays size of each trash directory.  See
    |vifm-menus-and-dialogs| for controls.

                                               *vifm-:tree*
:tree [depth=N]
    turn pane into tree view with current directory as its root.  The tree
    view is implemented on top of a custom view, but is automatically kept in
    sync with file system state and considers all the filters.  Thus the
    structure corresponds to what one would see on visiting the directories
    manually.  As a special case for trees built out of custom view
    file-system tracking isn't performed.

    To leave tree view go up from its root or use |vifm-gh| at any level of
    the tree.  Any command that changes directory will also do, in
    particular, `:cd ..`

    Tree structure is incompatible with alternative representations, so
    values of |vifm-'lsview'| and |vifm-'millerview'| options are ignored.

    The "depth" argument specifies nesting level on which loading of
    subdirectories won't happen (they will be folded).  Values start at 1.
:tree!
    toggle current view in and out of tree mode.

:undol[ist]                                    *vifm-:undolist* *vifm-:undol*
    display list of latest changes.  Use "!" to see actual commands.
    See |vifm-menus-and-dialogs| for controls.

:unl[et][!] {var}...                           *vifm-:unlet* *vifm-:unl*
    remove one or more environment (`$VAR`) or global (`g:global`) variables.
    Use "!" to omit displaying warnings about nonexistent variables.

                                               *vifm-:unselect*
:[range]unselect
    unselect files in the given range (current file if no range is given).
:unselect {pattern}
    unselect files that match specified pattern.  Possible {pattern} forms are
    described in |vifm-patterns|.  Trailing slash for directories is taken
    into account, so `:unselect */` unselects directories.
:unselect !{external command}
    unselect files from the list supplied by external command.  Files are
    matched by full paths, relative paths are converted to absolute ones
    beforehand.
:unselect //[iI]
    same as item above, but reuses last search pattern.

:ve[rsion]                                     *vifm-:version* *vifm-:ve*
    display menu with version information.

:vifm                                          *vifm-:vifm*
    same as :version.

                                               *vifm-:view* *vifm-:vie*
:vie[w]
    toggle on and off the quick file view (preview of file's contents).
    See also |vifm-'quickview'| option and |vifm-commands-and-selection|.
:vie[w]!
    turn on quick file view if it's off.

                                               *vifm-:volumes*
:volumes                                       {only for MS-Windows}
    display menu with volume list.  Hitting l (or Enter) key opens
    appropriate volume in the current pane.  See |vifm-menus-and-dialogs| for
    controls.

                                               *vifm-:vsplit* *vifm-:vs*
:vs[plit]
    switch to a two window vertical view.
:vs[plit]!
    toggle window vertical splitting.
:vs[plit] path
    split the window vertically to show both file directories.  Also changes
    other pane to the path (absolute or relative to current directory of active
    pane).

:[count]winc[md] {arg}                         *vifm-:wincmd* *vifm-:winc*
    same as running Ctrl-W [count] {arg}.

:windo [command...]                            *vifm-:windo*
    execute command for each pane (same as :winrun % command).

:wingo {id} [{substr}]                         *vifm-:wingo*
    navigate to a view by its id number.  The {substr} part is used for
    completion (can be any number of words, only leading whitespace is
    removed).  The view will become the current one by switching to the
    corresponding tab and pane.  Matching is case sensitive substring search
    in view title or its full current path (with `~` expanded regardless of
    any settings).
:wingo {substr}
    this form navigates to a view that is uniquely identified by {substr} or
    errors.  The form will not be used if the first word of {substr} is a
    valid number that starts with a digit (i.e., no `+` or `-` in front).

:winrun type [command...]                      *vifm-:winrun*
    execute command for pane(s), which is determined by type argument:
      - ^ - top-left pane
      - $ - bottom-right pane
      - % - all panes
      - . - current pane
      - , - other pane

:w[rite]                                       *vifm-:write* *vifm-:w*
    write current state to vifminfo and session files (if a session is
    active).

:wq[!]                                         *vifm-:wq*
    same as |vifm-:quit|, but "!" disables only the check of backgrounded
    commands, while state of the application is always written.

:wqa[ll][!]                                    *vifm-:wqall* *vifm-:wqa*
    same as |vifm-:qall|, but ! disables only the check of backgrounded
    commands, while state of the application is always written.

:xa[ll][!]                                     *vifm-:xall* *vifm-:xa*
    same as |vifm-:qall|.

:x[it][!]                                      *vifm-:xit* *vifm-:x*
    same as |vifm-:quit|.

:[range]y[ank] [reg] [count]                   *vifm-:yank* *vifm-:y*
    yank files to the reg register.

                                               *vifm-:map*
:map lhs rhs
    map lhs key sequence to rhs in normal and visual modes.
:map! lhs rhs
    map lhs key sequence to rhs in command line mode.

                                               *vifm-:amap*
                                               *vifm-:cmap* *vifm-:cm*
                                               *vifm-:dmap* *vifm-:dm*
                                               *vifm-:mmap* *vifm-:mm*
                                               *vifm-:nmap* *vifm-:nm*
                                               *vifm-:qmap* *vifm-:qm*
                                               *vifm-:vmap* *vifm-:vm*
:amap   lhs rhs - map lhs to rhs in navigation mode.
:cm[ap] lhs rhs - map lhs to rhs in command line mode.
:dm[ap] lhs rhs - map lhs to rhs in dialog modes.
:mm[ap] lhs rhs - map lhs to rhs in menu mode.
:nm[ap] lhs rhs - map lhs to rhs in normal mode.
:qm[ap] lhs rhs - map lhs to rhs in view mode.
:vm[ap] lhs rhs - map lhs to rhs in visual mode.

:amap   - list all maps of navigation mode.
:cm[ap] - list all maps of command line mode.
:dm[ap] - list all maps of dialog modes.
:mm[ap] - list all maps of menu mode.
:nm[ap] - list all maps of normal mode.
:qm[ap] - list all maps of view mode.
:vm[ap] - list all maps of visual mode.

:amap beginning
    list all maps of navigation mode that start with the beginning.
:cm[ap] beginning
    list all maps of command line mode that start with the beginning.
:dm[ap] beginning
    list all maps of dialog modes that start with the beginning.
:mm[ap] beginning
    list all maps of menu mode that start with the beginning.
:nm[ap] beginning
    list all maps of normal mode that start with the beginning.
:qm[ap] beginning
    list all maps of view mode that start with the beginning.
:vm[ap] beginning
    list all maps of visual mode that start with the beginning.

                                               *vifm-:noremap* *vifm-:no*
:no[remap] lhs rhs
    map the key sequence lhs to rhs for normal and visual modes, but
    don't expand user mappings in rhs.
:no[remap]! lhs rhs
    map the key sequence lhs to rhs for command line mode, but don't expand
    user mappings in rhs.

                                               *vifm-:anoremap*
                                               *vifm-:cnoremap* *vifm-:cno*
                                               *vifm-:dnoremap* *vifm-:dn*
                                               *vifm-:mnoremap* *vifm-:mn*
                                               *vifm-:nnoremap* *vifm-:nn*
                                               *vifm-:qnoremap* *vifm-:qn*
                                               *vifm-:vnoremap* *vifm-:vn*
:anoremap lhs rhs
    map the key sequence lhs to rhs for navigation mode, but don't expand
    user mappings in rhs.
:cno[remap] lhs rhs
    map the key sequence lhs to rhs for command line mode, but don't expand
    user mappings in rhs.
:dn[oremap] lhs rhs
    map the key sequence lhs to rhs for dialog modes, but don't expand user
    mappings in rhs.
:mn[oremap] lhs rhs
    map the key sequence lhs to rhs for menu mode, but don't expand user
    mappings in rhs.
:nn[oremap] lhs rhs
    map the key sequence lhs to rhs for normal mode, but don't expand user
    mappings in rhs.
:qn[oremap] lhs rhs
    map the key sequence lhs to rhs for view mode, but don't expand user
    mappings in rhs.
:vn[oremap] lhs rhs
    map the key sequence lhs to rhs for visual mode, but don't expand user
    mappings in rhs.

                                               *vifm-:unmap* *vifm-:unm*
:unm[ap] lhs
    remove user mapping of lhs from normal and visual modes.
:unm[ap]! lhs
    remove user mapping of lhs from command line mode.

                                               *vifm-:aunmap*
                                               *vifm-:cunmap* *vifm-:cu*
                                               *vifm-:dunmap* *vifm-:du*
                                               *vifm-:munmap* *vifm-:mu*
                                               *vifm-:nunmap* *vifm-:nun*
                                               *vifm-:qunmap* *vifm-:qun*
                                               *vifm-:vunmap* *vifm-:vu*
:aunmap   lhs - remove user mapping of lhs from navigation mode.
:cu[nmap] lhs - remove user mapping of lhs from command line mode.
:du[nmap] lhs - remove user mapping of lhs from dialog modes.
:mu[nmap] lhs - remove user mapping of lhs from menu mode.
:nun[map] lhs - remove user mapping of lhs from normal mode.
:qun[map] lhs - remove user mapping of lhs from view mode.
:vu[nmap] lhs - remove user mapping of lhs from visual mode.

:command parameters~
                                                       *vifm-:command-params*
Some of the command-line commands accept parameters in the form of
`-paramname`.  Arguments of such commands can be split into two groups:
parameters and positional arguments.  Items from the two groups cannot be
interleaved and parameters always come first.  List of parameters is
terminated implicitly by the first argument that doesn't start with a
dash ("-") or explicitly via "--" separator (needs to be a separate
argument), which is just discarded.  These strict rules allow arbitrary
positional arguments, such as file names that start with a dash.

-skip                                                      *vifm-skip-param*
This parameter makes |vifm-:copy|, |vifm-:move|, |vifm-:alink| and
|vifm-:rlink| automatically skip source files that already exist at the
destination rather than refusing to perform the operation.

Ranges~
                                                               *vifm-ranges*
The ranges implemented include:
  2,3 - from second to third file in the list (including it)
  % - the entire directory.
  . - the current position in the filelist.
  $ - the end of the filelist.
  't - the mark position t.

Examples:
  :%delete would delete all files in the directory.
  :2,4delete would delete the files in the list positions 2 through 4.
  :.,$delete would delete the files from the current position to the end
    of the filelist.
  :3delete4 would delete the files in the list positions 3, 4, 5, 6.

If a backward range is given :4,2delete - an query message is given and
user can chose what to do next.

The builtin commands that accept a range are :d[elete] and :y[ank].

Command macros~
                                                               *vifm-macros*
The command macros may be used in user commands.
                                                               *vifm-%a*
  %a        user arguments.  When user arguments contain macros, they are
            expanded before performing substitution of %a.
                                                               *vifm-%c*
  %c  %"c   the current file under the cursor.
                                                               *vifm-%C*
  %C  %"C   the current file under the cursor in the other directory.
                                                               *vifm-%f*
  %f  %"f   all of the selected files or the current file, but see
            |vifm-selection|.
                                                               *vifm-%F*
  %F  %"F   same as %f, %"f, but for the inactive pane.
                                                               *vifm-%l*
  %l  %"l   list of selected files.  Unlike %f from above, this is only for
            explicit selection (i.e., not via a range) and is empty if no
            files are selected.
                                                               *vifm-%L*
  %L  %"L   same as %l and %"l, but for the inactive pane.
                                                               *vifm-%b*
  %b  %"b   same as %f %F.
                                                               *vifm-%d*
  %d  %"d   full path to current directory.
                                                               *vifm-%D*
  %D  %"D   full path to other file list directory.
                                                               *vifm-%r*
  %rx %"rx  full paths to files in the register {x}.  In case of invalid
            symbol in place of {x}, it's processed with the rest of the
            line and default register is used.
                                                               *vifm-%m*
  %m        show command output in a menu.
                                                               *vifm-%M*
  %M        same as %m, but l (or Enter) key is handled like for :locate
            and :find commands.
                                                               *vifm-%u*
  %u        process command output as list of paths and compose custom view
            out of it.
                                                               *vifm-%U*
  %U        same as %u, but implies less list updates inside vifm, which is
            absence of sorting at the moment.
                                                               *vifm-%Iu*
  %Iu       same as %u, but gives up terminal before running external
            %command.
                                                               *vifm-%IU*
  %IU       same as %U, but gives up terminal before running external
            %command.
                                                               *vifm-%S*
  %S        show command output in the status bar.
                                                               *vifm-%q*
  %q        redirect command output to quick view, which is activated if
            disabled.
                                                               *vifm-%s*
  %s        execute command in horizontal split window of active terminal
            multiplexer (ignored if not running inside one).
                                                               *vifm-%v*
  %v        same as %s, but splits vertically.
                                                               *vifm-%n*
  %n        forbid use of terminal multiplexer to run the command.
                                                               *vifm-%N*
  %N        do not detach viewer from terminal session (keeps `/dev/tty`
            available) or process group (keeps the command in the set of
            foreground clients of the terminal).  This flag is a workaround
            for rare commands/terminals which might need a working TTY for
            |vifm-:fileviewer| command to operate correctly and has no effect
            otherwise.
                                                               *vifm-%i*
  %i        run in background and suppress error dialogs, but collect
            errors internally for viewing via |vifm-:jobs| menu.  This macro
            doesn't detach the command from terminal session (`/dev/tty`) on
            its own, add " &" to leave the command without access to the
            terminal.

                                                               *vifm-%Pl*
  %Pl       pipe list of files to standard input of a command.
                                                               *vifm-%Pz*
  %Pz       same as %Pl, but separates paths by null ('\0') character.

                                                               *vifm-%pc*
  %pc       marks the end of the main command and the beginning of the
            clear command for graphical preview, which is invoked on
            closing preview of a file.

                                                               *vifm-%pd*
  %pd       marks a preview command as one that directly communicates
            with the terminal.  Beware that this is for things like sixel
            which are self-contained sequences that depend only on current
            cursor position, using this with anything else is likely to
            mangle terminal state.

                                                               *vifm-%pu*
  %pu       uncached preview.  Intended to be used for commands that just
            send file path somewhere for preview.

  The following dimensions and coordinates are in characters:
                                                               *vifm-%px*
  %px       x coordinate of top-left corner of preview area.
                                                               *vifm-%py*
  %py       y coordinate of top-left corner of preview area.
                                                               *vifm-%pw*
  %pw       width of preview area.
                                                               *vifm-%ph*
  %ph       height of preview area.

Use %% if you need to put a percent sign in your command.

Note that %i, %Iu, %IU, %m, %M, %n, %q, %s, %S, %u, %U and %v macros are
mutually exclusive.  Only the last one of them in the command will take
effect.

Note that %Pl and %Pz are mutually exclusive.  Only the last one of them in
the command will take effect.

Note that a previewer containing %pd is considered a pass-through previewer,
otherwise a previewer containing both %px and %py is considered to be a
graphical previewer, the rest are treated as text previewers.

                                                     *vifm-filename-modifiers*
You can use file name modifiers after %c, %C, %f, %F, %b, %d and %D macros.
Supported modifiers are:
    :p           - full path
    :u           - UNC name of path (e.g. "\\server" in "\\server\share"),
                   Windows only.  Expands to current computer name for not
                   UNC paths.
    :~           - relative to the home directory
    :.           - relative to current directory
    :h           - head of the file name
    :t           - tail of the file name
    :r           - root of the file name (without last extension)
    :e           - extension of the file name (last one)
    :s?pat?sub?  - substitute the first occurrence of "pat" with "sub".  You
                   can use any character for '?', but it must not occur in pat
                   or sub
    :gs?pat?sub? - like :s, but substitutes all occurrences of "pat" with
                   "sub".
See |filename-modifiers| for the detailed description.

Using %x means expand corresponding macro escaping all characters that have
special meaning.  And %"x means using of double quotes and escape only backslash
and double quote characters, which is more useful on Windows systems.

Position and quantity (if there is any) of %m, %M, %S or %s macros in the
command is unimportant.  All their occurrences are removed from the resulting
command.

%c and %f macros are expanded to relative paths, while %C and %F are always
expanded to full paths.  The same applies to %f and %F implicitly used by %b.

:com move mv %f %D - set the :move command to move all of the files
selected in the current directory to the other directory.

The %a macro is replaced with any arguments given to an alias command.  All
arguments are considered optional.
:com lsl !!ls -l %a - set the lsl command to execute ls -l with or without an
argument.

:lsl<Enter> will list the directory contents of the current directory.
:lsl filename<Enter> will list only the given filename.

The macros can also be used in directly executing commands.
:!mv %f %D - would move the current directory selected files to the other
directory.

Appending & to the end of a command causes it to be executed in the
background.  Typically you want to run two kinds of external commands in the
background:
 - GUI applications that doesn't fork thus block vifm (:!sxiv %f &);
 - console tools that do not work with terminal (:!mv %f %D &).
You don't want to run terminal commands which require terminal input or
output something in background because they will mess up vifm's TUI.  Anyway,
if you did run such a command, you can use Ctrl-L key to update vifm's TUI.

Rewriting the example command with macros given above with backgrounding:
>
 :!mv %f %D &
<
%m, %M, %s, %S, %u and %U macros cannot be combined with background
mark (" &") as it doesn't make much sense.

--------------------------------------------------------------------------------
*vifm-commands-bg*

File system operations can take a lot of time to proceed.  That's why vifm
supports backgrounding them.  To run |vifm-:copy|, |vifm-:move| or |vifm-:delete|
command in background just append " &" to it.

For each background operation a new thread is created.  Job cancellation can
be requested in the |vifm-:jobs| menu via dd shortcut.

You can check if a command is still running in the |vifm-:jobs| menu.
Backgrounded commands have progress instead of process id at the beginning of
the line.

Background operations cannot be undone.

Also see |vifm-file-copying|.

--------------------------------------------------------------------------------
*vifm-cancellation*

Note that cancellation works somewhat different on Windows platform due to
different mechanism of break signal propagation.  One also might need to use
Ctrl-Break shortcut instead of Ctrl-C.

There are two types of operations that can be cancelled:
 - file system operations;
 - mounting with FUSE (but not unmounting as it can cause loss of data);
 - calls of external applications.

Note that vifm never terminates applications, it sends SIGINT signal and lets
the application quit normally.

When one of a set of operations is cancelled (e.g. copying of 5th file of 10
files), further operations are cancelled too.  In this case undo history will
contain only actually performed operations.

Cancelled operations are indicated by "(cancelled)" suffix appended to
information message on status bar.

File system operations~

Currently the following commands can be cancelled: |vifm-:alink|, |vifm-:chmod|,
|vifm-:chown|, |vifm-:clone|, |vifm-:copy|, |vifm-:delete|, |vifm-:mkdir|, |vifm-:move|,
|vifm-:restore|, |vifm-:rlink|, |vifm-:touch|.  File putting (|vifm-p|, |vifm-P|) can
be cancelled as well.  It's not hard to see that these are mainly
long-running operations.

Cancelling commands when they are repeated for undo/redo operations is allowed
for convenience, but is not recommended as further undo/redo operations might
get blocked by side-effects of partially cancelled group of operations.

These commands can't be cancelled: |vifm-:empty|, |vifm-:rename|,
|vifm-:substitute|, |vifm-:tr|.

Mounting with FUSE~

It's not considered to be an error, so only a notification on the status bar is
shown.

External application calls~

Each of these operations can be cancelled: |vifm-:apropos|, |vifm-:find|,
|vifm-:grep|, |vifm-:locate|.

--------------------------------------------------------------------------------
*vifm-selection*

If there is a selection, it's stashed before proceeding further unless file
under the cursor is part of that selection.  This means that when macros are
expanded for |vifm-:filetype| or |vifm-:filextype| programs, `%f` and `%F`
become equivalent to `%c` and `%C` respectively if current file is not selected.
So you run selection by running one of selected files, otherwise you're
running a single file even if there are other selected entries.

When running a selection it must not include broken symbolic links, has to be
consistent and set of file handlers must be compatible.  Consistency means
that selection contains either only directories (including links to them) or
only files, but not their mix.

Compatibility is a more sophisticated check, but it's defined in a natural way
so that you get what you'd expect.  The following properties of selection are
taken into account while checking it for compatibility and deciding how to
handle it:

    1. If there any files for which handler isn't defined, then all files are
       opened using |vifm-'vicmd'| or |vifm-'vixcmd'|.

    2. If all handlers match the following criteria:
        - backgrounded
        - include `%c`/`%"c` and/or `%C`/`%"C`
        - include neither `%f`/`%"f` nor `%F`/`%"F`
       then each file is executed independently of the rest.

    3. If all handlers are equal, the common handler is executed.  This
       handler might ignore selection and process only file under the cursor.

    4. Otherwise, an error is reported, because handlers differ and they
       don't support parallel execution.

--------------------------------------------------------------------------------
*vifm-patterns*

|vifm-:highlight|, |vifm-:filetype|, |vifm-:filextype|, |vifm-:fileviewer|
commands and |vifm-'classify'| option support globs, regular expressions and
mime types to match file names or their paths.  Directory paths get an
implicit trailing slash on matching against a pattern, keep that in mind for
globs or regular expressions that end with `$`.

There are six possible ways to write a single pattern:
 1. [!]{comma-separated-name-globs}
 2. [!]{{comma-separated-path-globs}}
 3. [!]/name-regular-expression/[iI]
 4. [!]//path-regular-expression//[iI]
 5. [!]<comma-separated-mime-type-globs>
 6. undecorated-pattern

First five forms can include leading exclamation mark that negates pattern
matching.

The last form is implicitly refers to one of the others.  |vifm-:highlight|
does not accept undecorated form, while |vifm-:filetype|, |vifm-:filextype|,
|vifm-:fileviewer|, |vifm-:select|, |vifm-:unselect| and |vifm-'classify'|
treat it as list of name globs.

Path patterns receive absolute path of the file that includes its name
component as well.

To combine several patterns (AND them), make sure you're using one of the
first five forms and write patterns one after another, like this: >
 <text/plain>{*.vifm}
Mind that if you make a mistake the whole string will be treated as the sixth
form.

|vifm-:filetype|, |vifm-:filextype| and |vifm-:fileviewer| commands accept
comma-separated list of patterns instead of a single pattern, thus effectively
handling OR operation on them: >
 <text/plain>{*.vifm},<application/pdf>{*.pdf}
Forms that accept comma-separated lists of patterns also process them as
lists of alternatives.

Patterns with regular expressions~

Regular expression patterns are case insensitive by default, see description
of commands, which might override default behaviour.

Flags of regular expressions mean the following:
  - "i" makes filter case insensitive;
  - "I" makes filter case sensitive.
They can be repeated multiple times, but the later one takes precedence (e.g.
"iiiI" is equivalent to "I" and "IiIi" is the same as "i").

There are no implicit `^` or `$`, so make sure to specify them explicitly if
the pattern should match the whole name or path.

Patterns with globs~

|vifm-globs| section provides short overview of globs and some important points
that one needs to know about them.

Patterns with mime-types~

Mime type matching is essentially globs matching applied to mime type of a file
instead of its name/path.  Note: mime types aren't detected on Windows.

Examples~

Associate `evince` to PDF-files only inside `/home/user/downloads/` directory
(excluding its subdirectories): >
 :filextype //^/home/user/downloads/[^/]*\.pdf$// evince %f

--------------------------------------------------------------------------------
*vifm-regexp*

All regular expressions are extended.  See `man 7 regex` for more details on
what's supported.

The following special sequences are additionally parsed:
 - `\c` forces matching ignoring case of letters
 - `\C` forces matching respecting case of letters

`\c` and `\C` have the highest priority in determining whether case is matched
or not and exist to override |vifm-'ignorecase'|, |vifm-'smartcase'| and
`i`/`I` flags when necessary.

If multiple sequences are present, the one which appears later takes
precedence.

Note that unlike in Vim character classes are affected by settings and
sequences that control case sensitivity in regular expressions.

--------------------------------------------------------------------------------
*vifm-globs*

Globs are always case insensitive as it makes sense in general case.

`*`, `?`, `[` and `]` are treated as special symbols in the pattern.  E.g. >
 :filetype * less %c
matches all files.  One can use character classes for escaping, so >
 :filetype [*] less %c
matches only one file name, the one which contains only asterisk symbol.

`*` means any number of any characters (including slash) and can match an empty
substring, with one exception: asterisk at the pattern beginning doesn't match
dot in the first position.  E.g. >
 :fileviewer *.zip,*.jar zip -sf %c
associates using of `zip` program to preview all files with `zip` or `jar`
extensions as listing of their content, but `.file.zip` won't be matched.

`?` means any character at this position.  E.g. >
 :fileviewer ?.out file %c
calls `file` tool for all files which have exactly one character before their
extension (e.g. a.out, b.out).

Square brackets designate character class, which means that whole character
class matches against any of characters listed in it.  For example >
 :fileviewer *.[ch] highlight -O xterm256 -s dante --syntax c %c
makes vifm call `highlight` program to colorize source and header files in C
language for a 256-color terminal.  Equal command would be >
 :fileviewer *.c,*.h highlight -O xterm256 -s dante --syntax c %c

Inside square brackets `^` or `!` can be used for symbol class negation and
the `-` symbol to set a range.  `^` and `!` should appear right after the opening
square bracket.  For example >
 :filetype *.[!d]/ inspect_dir
associates `inspect_dir` as additional handler for all directories that have one
character extension unless it's "d" letter.  And >
 :filetype [0-9].jpg sxiv
associates `sxiv` picture viewer only for JPEG-files that contain single digit
in their name.

If you need to include literal comma, which normally separates multiple globs,
double it.

--------------------------------------------------------------------------------
*vifm-set-options*

                                               *vifm-local-options*
These are kind of options that are local to a specific view.  So you can set
ascending sorting order for left pane and descending order for right pane.

In addition to being local to views, each such option also has two values:
 - local to current directory (value associated with current location);
 - global to current directory (value associated with the pane).

The idea is that current directory can be made a temporary exception to
regular configuration of the view, until directory change.  Use
|vifm-:setlocal| for that.  |vifm-:setglobal| changes view value not affecting
settings until directory change.  |vifm-:set| applies changes immediately to
all values.

                                               *vifm-'aproposprg'*
aproposprg
type: string
default: "apropos %a"

Specifies format for an external command to be invoked by the |vifm-:apropos|
command.  The format supports expanding of macros, specific for a particular
*prg option, and %% sequence for inserting percent sign literally.  This
option should include the %a macro to specify placement of arguments passed
to the |vifm-:apropos| command.  If the macro is not used, it will be
implicitly added after a space to the value of this option.

                                               *vifm-'autocd'*
autocd
type: boolean
default: false

When enabled unknown command-line commands are interpreted as implicit
invocation of |vifm-:cd| with one argument and no escaping.  Tilde is
expanded, but not macros or environment variables.

                                               *vifm-'autochpos'*
autochpos
type: boolean
default: true

When disabled vifm will set cursor to the first line in the view after :cd and
:pushd commands instead of saved cursor position.  Disabling this will also
make vifm clear information about cursor position in the view history on :cd
and :pushd commands (and on startup if 'autochpos' is disabled in the vifmrc).
l key in the ":history ." and ":trashes" menus are treated like :cd command.
This option also affects marks so that navigating to a mark doesn't restore
cursor position.

When this option is enabled, more fine grained control over cursor position
is available via |vifm-'histcursor'| option.

                                               *vifm-'caseoptions'*
caseoptions
type: charset
default: ""

This option gives additional control over case sensitivity by allowing
overriding default behaviour to either always be case sensitive or
always be case insensitive.  Possible values form pairs of lower and upper
case letters that configure specific aspect of behaviour:
  p - always ignore case of paths during completion.
  P - always match case of paths during completion.
  g - always ignore case of characters for f/F/;/,.
  G - always match case of characters for f/F/;/,.

At most one item of each pair takes affect, if both or more are present, only
the last one matters.  When of none pair's elements are present, the behaviour
is default (depends on operating system for path completion and on values of
|vifm-'ignorecase'| and |vifm-'smartcase'| options for file navigation).

                                               *vifm-'cdpath'* *vifm-'cd'*
cdpath cd
type: string list
default: value of $CDPATH with commas instead of colons

Specifies locations to check on changing directory with relative path that
doesn't start with "./" or "../".  When non-empty, current directory is
examined after directories listed in the option.

This option doesn't affect completion of |vifm-:cd| command.

Example: >
 set cdpath=~
This way ":cd bin" will switch to "~/bin" even if directory named "bin" exists
in current directory, while ":cd ./bin" command will ignore value of 'cdpath'.

                                               *vifm-'chaselinks'*
chaselinks
type: boolean
default: false

When enabled path of view is always resolved to real path (with all symbolic
links expanded).

                                               *vifm-'classify'*
classify
type: string list
default: ":dir:/"

Specifies file name prefixes and suffixes depending on file type or name (mind
that directory names have an implicit trailing slash).  The format is either
of:
  - [{prefix}]:{filetype}:[{suffix}]
  - [{prefix}]::{pattern}::[{suffix}]
Possible {pattern} forms are described in |vifm-patterns|.

Priority rules:
  - file name patterns have priority over type patterns
  - file name patterns are matched in left-to-right order of their appearance
    in this option

Either {prefix} or {suffix} or both can be omitted (which is the default for
all unspecified file types), this means empty {prefix} and/or {suffix}.
{prefix} and {suffix} should consist of at most eight characters.  Elements
are separated by commas.  Neither prefixes nor suffixes are part of file names,
so they don't affect commands which operate on file names in any way.  Comma
(',') character can be inserted by doubling it.  List of file type names can be
found in the description of |vifm-filetype()| function.

                                               *vifm-'columns'* *vifm-'co'*
columns co
type: integer
default: terminal width on startup

Terminal width in characters.

                                               *vifm-'confirm'* *vifm-'cf'*
confirm cf
type: set
default: delete,permdelete

Defines which operations require confirmation:
 - delete     - moving files to trash (on |vifm-d| or |vifm-:delete|);
 - permdelete - permanent deletion of files (on |vifm-D| or :delete!
                command or on undo/redo operation).

                                               *vifm-'cpoptions'* *vifm-'cpo'*
cpoptions cpo
type: charset
default: "fst"

Contains a sequence of single-character flags.  Each flag enables behaviour of
older versions of vifm.  Flags:
                                               *vifm-cpo-f*
f - when included, running |vifm-:filter| command results in not inverted
    (matching files are filtered out) and :filter! in inverted (matching files
    are left) filter, when omitted, meaning of the exclamation mark changes to
    the opposite;
                                               *vifm-cpo-s*
s - when included, |vifm-yy|, |vifm-Y|, |vifm-dd| and |vifm-DD| normal mode commands act
    on selection if there is any, otherwise they operate on the current file;
    when omitted, those commands always operate on the current file;
                                               *vifm-cpo-t*
t - when included, <tab> (thus <c-i>) behave as <space> and switch active
    pane, otherwise <c-i> goes forward in the view history.  It's possible to
    make both <tab> and <c-i> to work as expected by setting up the terminal
    to emit a custom sequence when <c-i> is pressed; see :histnext for
    details.

                                               *vifm-'cvoptions'*
cvoptions
type: set
default:

Specifies whether entering/leaving custom views triggers events that normally
happen on entering/leaving directories:
 - autocmds    - trigger autocommands on entering/leaving custom views;
 - localopts   - reset local options on entering/leaving custom views;
 - localfilter - reset local filter on entering/leaving custom views.

                                               *vifm-'deleteprg'*
deleteprg
type: string
default: ""

Specifies program to run on files that are permanently removed.  When empty,
files are removed as usual, otherwise this command is invoked on each file by
appending its name.  If the command doesn't remove files, they will remain on
the file system.

                                               *vifm-'dirsize'*
dirsize
type: enumeration
default: size

Controls how size of directories is displayed in file views.  The following
values are possible:
 - size   - size of directory (i.e., size used to store list of files)
 - nitems - number of entries in the directory (excluding . and ..)

Size obtained via ga/gA overwrites this setting so seeing count of files and
occasionally size of directories is possible.

                                               *vifm-'dotdirs'*
dotdirs
type: set
default: nonrootparent,treeleafsparent

Controls displaying of dot directories.  The following values are possible:
 - rootparent      - show "../" in root directory of file system
 - nonrootparent   - show "../" in non-root directories of file system
 - treeleafsparent - show "../" in empty directories of tree view

Note that empty directories always contain "../" entry regardless of value of
this option.  "../" disappears at the moment at least one file is created.

                                               *vifm-'dotfiles'*
dotfiles
type: boolean
default: false

Whether dot files are shown in the view.  Can be controlled with z* bindings.

                                               *vifm-'fastrun'*
fastrun
type: boolean
default: false

With this option turned on you can run partially entered commands with
unambiguous beginning using :! (e.g. :!Te instead of :!Terminal or :!Te<tab>).

                                               *vifm-'fillchars'* *vifm-'fcs'*
fillchars fcs
type: string list
default: ""

Sets characters used to fill borders.

    item          default         used for ~
    hborder:c     ''              middle horizontal border
    millersep:c   ''              separator of miller columns
    vborder:c     ' '             left, middle and right vertical borders

An empty string for millersep or vborder is equivalent to a space.

An empty string for hborder omits the horizontal border.

Example: >
    set fillchars=vborder:".",hborder:"",millersep:"|"
<
                                               *vifm-'findprg'*
findprg
type: string
default: "find %s %a"

Specifies format for an external command to be invoked by the |vifm-:find|
command.  The format supports expansion of macros specific for this particular
option and %% sequence for inserting percent sign literally.  The macros are:

  macro   value/meaning~
   %s     literal arguments of :find or
          list of paths to search in

   %A     empty or
          literal arguments of :find
   %a     empty or
          literal arguments of :find or
          predicate followed by escaped arguments of :find
   %p     empty or
          literal arguments of :find or
          escaped arguments (parameters) of :find

   %u     redirect output to custom view instead of showing a menu
   %U     redirect output to unsorted custom view instead of showing a menu

Predicate in %a is "-name" on *nix and "-iname" on Windows.

If both %u and %U are specified, %U is chosen.

Some macros can be added implicitly:
 - if %s isn't present, it's appended
 - if neither of %a, %A and %p is present, %a is appended
 - if neither of %s, %a, %A and %p is present, %s and %a are appended in this
   order

The macros slightly change their meaning depending on format of :find's
arguments:
 - if the first argument points to an existing directory, %s is assigned all
   arguments while %a, %A and %p are left empty
 - otherwise:
    - %s is assigned a dot (".") meaning current directory or list of
      selected file names, if any
    - %a, %A and %p are assigned literal arguments when first argument starts
      with a dash ("-"), otherwise %a gets an escaped version of the arguments
      with a predicate and %p contains escaped version of the arguments

Starting with Windows Server 2003 a `where` command is available.  One can
configure vifm to use it in the following way: >
    set findprg="where /R %s %A"
<
As the syntax of this command is rather limited, one can't use |vifm-:find|
command with selection of more than one item because the command ignores all
directory paths except for the last one.

When using find port on Windows, another option is to setup 'findprg' like
this: >
    set findprg="find %s %a"
<
                                               *vifm-'followlinks'*
followlinks
type: boolean
default: true

Follow links on l or Enter.  That is navigate to destination file instead of
treating the link as if it were target file.  Doesn't affects links to
directories, which are always entered (use |vifm-gf| for directories).

                                               *vifm-'fusehome'*
fusehome
type: string
default: "($XDG_DATA_HOME/vifm | $VIFM)/fuse/"

Directory to be used as a root dir for FUSE mounts.  Value of the option can
contain environment variables (in form "$envname"), which will be expanded
(prepend it with a slash to prevent expansion).  The value should expand to
an absolute path.

If you change this option, vifm won't remount anything.  It affects future
mounts only.  See |vifm-fuse| section for more information about FUSE mounts.

                                               *vifm-'gdefault'* *vifm-'gd'*
gdefault gd
type: boolean
default: false

When on, 'g' flag is on for |vifm-:substitute| by default.

                                               *vifm-'grepprg'*
grepprg
type: string
default: "grep -n -H -I -r %i %a %s"

Specifies format for an external command to be invoked by the |vifm-:grep|
command.  The format supports expanding of macros, specific for a particular
*prg option, and %% sequence for inserting percent sign literally.  This
option should include the %i macro to specify placement of "-v" string when
inversion of results is requested, %a or %A macro to specify placement of
arguments passed to the |vifm-:grep| command and the %s macro to specify
placement of list of files to search in.  If some of the macros are not
used, they will be implicitly added after a space to the value of the
|vifm-'grepprg'| option in the following order: %i, %a, %s.  Note that when
neither %a nor %A are specified, it's %a which is added implicitly.

Optional %u or %U macro could be used (if both specified %U is chosen) to
force redirection to custom or unsorted custom view respectively.

See |vifm-'findprg'| for description of difference between %a and %A.

Example of setup to use ack (http://beyondgrep.com/) instead of grep:
>
    set grepprg='ack -H -r %i %a %s'
<
or The Silver Searcher (https://github.com/ggreer/the_silver_searcher):
>
    set grepprg='ag --line-numbers %i %a %s'
<
                                               *vifm-'histcursor'*
histcursor
type: set
default: startup,dirmark,direnter

Defines situations when cursor should be moved according to directory
history:
 - startup  - on loading file lists during startup
 - dirmark  - after navigating to a mark that doesn't specify file
 - direnter - on opening directory from a file list

This option has no effect when |vifm-'autochpos'| is disabled.

Note that the list is not exhaustive and there are other situations when
cursor is positioned automatically.
                                               *vifm-'history'* *vifm-'hi'*
history hi
type: integer
default: 15

Maximum number of stored items in all histories.

                                               *vifm-'hloptions'*
type: string list
default: "filehi:onerow"

Configures behaviour of highlighting.

    item        default~
    filehi:str  onerow

The "filehi" item specifies which columns of the view get colored according to
file type and its name:
 - path    - highlight columns that display file path, name, root or extension
 - onerow  - same as "path" and also highlight all columns of the current line
 - allrows - highlight all columns of each row

                                               *vifm-'hlsearch'* *vifm-'hls'*
hlsearch hls
type: boolean
default: true

Automatically select files that are search matches.

                                               *vifm-'iec'*
iec
type: boolean
default: false

Use KiB, MiB, ... suffixes instead of K, M, ... when printing size in
human-friendly format.

                                               *vifm-'ignorecase'* *vifm-'ic'*
ignorecase ic
type: boolean
default: false

Ignore case in search patterns (:substitute, / and ? commands), local filter
(but not the rest of filters) and other things detailed in the description of
|vifm-'caseoptions'|.

                                               *vifm-'incsearch'* *vifm-'is'*
incsearch is
type: boolean
default: false

When this option is set, search and view update for local filter is be
performed starting from initial cursor position each time search pattern is
changed.

                                               *vifm-'iooptions'*
iooptions
type: set
default: datasync

Controls details of file operations.  The following values are available:
 - datasync - periodically synchronize writes on copying files when
              |vifm-'syscalls'| is set.
              (This makes copying last as long as it takes to actually write
              data to the medium, which is slower than you might expect;
              however, this also prevents system hanging due to filling memory
              with file-system cache.)
 - fastfilecloning - perform fast file cloning (copy-on-write), when available
                     (available on Linux and btrfs file system).

                                               *vifm-'laststatus'* *vifm-'ls'*
laststatus ls
type: boolean
default: true

Controls if status bar is visible.

                                               *vifm-'lines'*
lines
type: integer
default: terminal height on startup

Terminal height in lines.

                                               *vifm-'locateprg'*
locateprg
type: string
default: "locate %a"

Specifies format for an external command to be invoked by the |vifm-:locate|
command.  The format supports expanding of macros, specific for a particular
*prg option, and %% sequence for inserting percent sign literally.  This
option should include the %a macro to specify placement of arguments passed
to the |vifm-:locate| command.  If the macro is not used, it will be
implicitly added after a space to the value of this option.

Optional %u or %U macro could be used (if both specified %U is chosen) to
force redirection to custom or unsorted custom view respectively.

                                               *vifm-'mediaprg'*
                                               {only for *nix}
mediaprg
type: string
default: path to bundled script that supports udevil, udisks and udisks2
         (using udisks2 requires python with dbus module installed)
         OS X: path points to a python script that uses diskutil

Specifies command to be used to manage media devices.  Used by |vifm-:media|
command.

The command can be passed the following parameters:
 - list           -- list media
 - mount {device} -- mount a device
 - unmount {path} -- unmount given mount point

The output of `list` subcommand is parsed in search of lines that start with
one of the following prefixes:
 - device=      - specifies device path (e.g., "/dev/sde")
 - label=       - specifies optional device label (e.g., "Memory card")
 - info=        - specifies arbitrary text to display next to device (by
                  default "[label]" is used, if label is provided)
 - mount-point= - specifies a mount point (can be absent or appear more than
                  once)

All other lines are ignored.  Each `device=` starts a new section
describing a device which should include two other possible prefixes.

`list` subcommand is assumed to always succeed, while exit code of `mount`
and `unmount` is taken into account to determine whether operation was
performed successfully.

                                               *vifm-'lsoptions'*
lsoptions
type: string list
default: ""
scope: local

Configures ls-like view.

    item          used for ~
    columncount   fixed number of columns to display or 0
    transposed    filling view grid by columns rather than by lines

                                               *vifm-'lsview'*
lsview
type: boolean
default: false
scope: local

When this option is set, directory view will be displayed in multiple
columns with file names similar to output of `ls -x` command.  See also
|vifm-ls-view|.  This option has no effect if |vifm-'millerview'| is on.

                                               *vifm-'milleroptions'*
milleroptions
type: string list
default: "lsize:1,csize:1,rsize:1,rpreview:dirs"
scope: local

Configures miller view.

    item          default     used for ~
    lsize:num     0           left column
    csize:num     1           center column (can't be disabled)
    rsize:num     0           right column
    rpreview:str  dirs        right column

*size specifies ratios of columns.  Each ratio is in the range from
0 to 100 and values are adjusted to fit the limits.  Zero disables a
column, but central (main) column can't be disabled.

rpreview specifies what file-system objects should be previewed in the right
column and takes three values: dirs (only directories), files (only files) or
all.  Neither value enables preview of parent directory ("..").

Example of two-column mode which is useful in combination with
|vifm-:view| command: >
 set milleroptions=lsize:1,csize:2
<
                                               *vifm-'millerview'*
millerview
type: boolean
default: false
scope: local

When this option is set, directory view will be displayed in multiple
cascading columns.  Ignores |vifm-'lsview'|.

                                               *vifm-'mintimeoutlen'*
mintimeoutlen
type: integer
default: 150

The fracture of |vifm-'timeoutlen'| in milliseconds that is waited between
subsequent input polls, which affects various asynchronous
operations (detecting changes made by external applications, monitoring
background jobs, redrawing UI).  There are no strict guarantees, however the
higher this value is, the less is CPU load in idle mode.

                                               *vifm-'mouse'*
mouse
type: charset
default: ""

Contains a sequence of single-character flags:
 - a - all supported modes (a shorthand for all the rest and future additions)
 - c - command-line mode (includes navigation mode)
 - m - menu mode
 - n - normal mode
 - q - view mode
 - v - visual mode

                                               *vifm-'navoptions'*
navoptions
type: string list
default: "open:dirs"

Configures behaviour of navigation mode.

    item      default~
    open:str  dirs

The "open" item specifies what file-system objects should be opened on
|vifm-a_Enter| and can take two values: dirs (only directories) or all.

                                               *vifm-'number'* *vifm-'nu'*
number nu
type: boolean
default: false
scope: local

Print line number in front of each file name when |vifm-'lsview'| option is
turned off.  Use |vifm-'numberwidth'| to control width of line number.
Also see |vifm-'relativenumber'|.

                                               *vifm-'numberwidth'* *vifm-'nuw'*
numberwidth nuw
type: integer
default: 4
scope: local

Minimal number of characters for line number field.

                                               *vifm-'previewoptions'*
previewoptions
type: string list
default: "graphicsdelay:50000"

Tweaks how previewing is done (in quick view, miller view's column and
view mode).

    item               default  meaning ~
    graphicsdelay:num  0        delay before drawing graphics (microseconds)
    hardgraphicsclear  unset    redraw screen to get rid of graphics
    maxtreedepth:num   0        max number of levels in preview tree
    toptreestats       unset    show file counts before the tree

graphicsdelay is needed if terminal requires some timeout before it can
draw graphics (otherwise it gets lost).

hardgraphicsclear seems to be necessary to get rid of sixel graphics in some
terminals, where it otherwise lingers.  This can cause flicker on the screen
due to erasure followed by redrawing.

0 for maxtreedepth means "unlimited", 1 will only show selected directory, 2
adds its children, and so forth.

Default value is used when item is missing from the option.

                                               *vifm-'previewprg'*
previewprg
type: string
default: ""
scope: local

External command to be used instead of preview programs configured via
|vifm-:fileviewer| command.

Example: >
    " always show git log in preview of files inside some repository
    au DirEnter '~/git-repo/**/*' setl previewprg='git log --color -- %c 2>&1'
<
                                               *vifm-'quickview'*
quickview
type: boolean
default: false

Whether quick view (|vifm-:view|) is currently active or not.

                                               *vifm-'relativenumber'*
                                               *vifm-'rnu'*
relativenumber rnu
type: boolean
default: false
scope: local

Print relative line number in front of each file name when |vifm-'lsview'|
option is turned off.  Use |vifm-'numberwidth'| to control width of line
number.  Various combinations of |vifm-'number'| and |vifm-'relativenumber'|
lead to such results:

                        nonumber               number

    norelativenumber   | first                |   1 first
                       | second               |   2 second
                       | third                |   3 third

      relativenumber   |   1 first            |   1 first
                       |   0 second           |2    second
                       |   1 third            |   1 third

                                               *vifm-'rulerformat'* *vifm-'ruf'*
rulerformat ruf
type: string
default: "%l/%S "

Determines the content of the ruler.  Its minimal width is 13 characters and
it's right aligned.  Following macros are supported:
    %=  - separation point between left and right aligned halves of the line
    %l  - file number
    %L  - total number of files in view (including filtered out ones)
    %x  - number of files excluded by filters
    %0- - old name for %x macro
    %P  - percentage through file list (All, Top, xx% or Bot), always 3 in
          length
    %S  - number of displayed files
    %%  - literal percent sign
    %[  - designates beginning of an optional block
    %]  - designates end of an optional block

Percent sign can be followed by optional minimum field width.  Add '-' before
minimum field width if you want field to be right aligned.

Optional blocks are ignored unless at least one macro inside of them is
expanded to a non-empty value.

Example: >
 set rulerformat='%2l-%S%[ +%x%]'
<
                                               *vifm-'runexec'*
runexec
type: boolean
default: false

Run executable file on Enter, l or Right Arrow key.  Behaviour of the last two
depends on the value of the |vifm-'lsview'| option.

                                               *vifm-'scrollbind'* *vifm-'scb'*
scrollbind scb
type: boolean
default: false

When this option is set, vifm will try to keep difference of scrolling
positions of two windows constant.

                                               *vifm-'scrolloff'* *vifm-'so'*
scrolloff so
type: integer
default: 0

Minimal number of screen lines to keep above and below the cursor.  If you
want cursor line to always be in the middle of the view (except at the
beginning or end of the file list), set this option to some large value
(e.g. 999).

                                               *vifm-'sessionoptions'*
                                               *vifm-'ssop'*
sessionoptions ssop
type: set
default: tui,state,tabs,savedirs,dhistory

An equivalent of |vifm-'vifminfo'| for sessions, uses the same values.  When
both options include the same value, data from session file has higher
priority (data from vifminfo isn't necessarily completely discarded,
instead it's merged with the state of a session the same way state of
multiple instances is merged on exit).

                                               *vifm-'shell'* *vifm-'sh'*
shell sh
type: string
default: $SHELL or "/bin/sh" or "cmd" (on MS-Windows)

Full path to the shell to use to run external commands.  On *nix a shell
argument can be supplied.

                                               *vifm-'shellcmdflag'*
                                               *vifm-'shcf'*
shellcmdflag shcf
type: string
default: "-c" or "/C" (for cmd.exe on MS-Windows)

Command-line option used to pass a command to |vifm-'shell'|.  It's used in
contexts where command comes from the user.

Note that using this option to force interactive mode of the shell is most
likely a BAD IDEA.  In general interactive host and interactive child shell
can't share the same terminal session.  You can't even run such a shell in
background.  Consider writing a wrapper for your shell that preloads aliases
and commands without making the shell interactive and ending up using it in
a way it was not meant to be used.

Note that this option is ignored when |vifm-'shell'| is set to PowerShell due
to the internal use of `-encodedCommand`.

                                               *vifm-'shortmess'* *vifm-'shm'*
shortmess shm
type: charset
default: "p"

Contains a sequence of single-character flags.  Each flag enables shortening
of some message displayed by vifm in the TUI.  Flags:
  L - display only last directory in tab line instead of full path.
  M - shorten titles in windows of terminal multiplexers created by vifm
      down to file name instead of using full path.
  T - truncate status bar messages in the middle if they are too long to fit on
      the command line.  "..." will appear in the middle.
  p - use tilde shortening in view titles.

                                               *vifm-'showtabline'*
                                               *vifm-'stal'*
showtabline stal
type: enumeration
default: multiple

Specifies when tab line should be displayed.  Possible values:
 - never    - never display tab line
 - multiple - show tab line only when there are at least two tabs
 - always   - display tab line always

Alternatively 0, 1 and 2 Vim-like values  are also accepted and correspond to
"never", "multiple" and "always" respectively.

                                                *vifm-'sizefmt'*
sizefmt
type: string list
default: "units:iec"

Configures the way size is formatted in human-friendly way.

    item          value         meaning~
    units:        iec           Use 1024 byte units (K or KiB, etc.).
                                See |vifm-'iec'|.
                  si            Use 1000 byte units (KB, etc.).
    precision:    i > 0         How many fraction digits to consider.
                  {not set}     Precision of 1 for integer part < 10,
                                0 otherwise (provides old behaviour).
    space         {present}     Insert space before unit symbols.
                                This is the default.
    nospace       {present}     Do not insert space before unit symbols.

Numbers are rounded from zero.  Trailing zeros are dropped.

Example: >
 set sizefmt=units:iec,precision:2,nospace
<
                                               *vifm-'slowfs'*
                                               {only for *nix}
slowfs
type: string list
default: ""

A list of mounter fs name beginnings (first column in /etc/mtab or
/proc/mounts) or paths prefixes for fs/directories that work too slow for
you.  This option can be used to stop vifm from making some requests to
particular kinds of file systems that can slow down file browsing.
Currently this means don't check if directory has changed, skip check if
target of symbolic links exists, assume that link target located on slow fs
to be a directory (allows entering directories and navigating to files via
|vifm-gf|).  If you set the option to "*", it means all the systems are
considered slow (useful for cygwin, where all the checks might render vifm
very slow if there are network mounts).

Example for autofs root /mnt/autofs: >
  set slowfs+=/mnt/autofs
<
                                               *vifm-'smartcase'* *vifm-'scs'*
smartcase scs
type: boolean
default: false

Overrides the |vifm-'ignorecase'| option if a pattern contains at least one
upper case character.  Only used when |vifm-'ignorecase'| option is enabled.

                                               *vifm-'sort'*
sort
type: enumeration
default: +name on *nix and +iname on Windows
scope: local

Sets list of sorting keys (first item is primary key, second is secondary
key, etc.):
   [+-]ext     - extension of files and directories
   [+-]fileext - extension of files only
   [+-]name    - name (including extension)
   [+-]iname   - name (including extension, ignores case)
   [+-]type    - file type (dir/reg/exe/link/char/block/sock/fifo)
   [+-]dir     - directory grouping (directory < file)
   [+-]gid     - group id (*nix only)
   [+-]gname   - group name (*nix only)
   [+-]mode    - file mode (file type + permissions) in octal (*nix only)
   [+-]perms   - permissions string (*nix only)
   [+-]uid     - owner id (*nix only)
   [+-]uname   - owner name (*nix only)
   [+-]nlinks  - number of hard links (*nix only)
   [+-]inode   - inode number (*nix only)
   [+-]size    - size
   [+-]nitems  - number of items in a directory (zero for files)
   [+-]groups  - groups extracted via regexps from |vifm-'sortgroups'|
   [+-]target  - symbolic link target (empty for other file types)
   [+-]atime   - time accessed (e.g., read, executed)
   [+-]ctime   - time changed (changes in metadata, like mode)
   [+-]mtime   - time modified (when file contents is changed)

Note: look for st_atime, st_ctime and st_mtime in "man 2 stat" for more
information on time keys.

'+' means ascending sort for this key, and '-' means descending sort.

"dir" key is somewhat similar in this regard but it's not added implicitly:
when "dir" is not specified, sorting behaves as if it was the first key in
the list.  That's why if one wants sorting algorithm to mix directories and
files, "dir" should be appended to sorting option, for example like this: >
 set sort+=dir
or >
 set sort=-size,dir

This option also changes view columns according to primary sorting key set,
unless |vifm-'viewcolumns'| option is not empty.

Value of the option is checked to include "dir" key and default sorting key
"(name" on *nix, "iname" on Windows).  Here is what happens if one of them is
missing:
 - "dir" key is added at the beginning;
 - default key is added at the end.
All other keys are left untouched (at most they are moved).

This option also changes view columns according to primary sorting key set,
unless |vifm-'viewcolumns'| option is not empty.

                                               *vifm-'sortnumbers'*
sortnumbers
type: boolean
default: false

Natural sort of (version) numbers within text.

                                               *vifm-'sortgroups'*
sortgroups
type: string
default: ""
scope: local

Sets comma-separated list of regular expressions for group type of sorting.
Double the comma to insert it literally.

The regular expressions are used to extract substrings of file names to serve
as keys for sorting.  It is essentially a way to ignore uninteresting parts
of file names during sorting by name.

Each expression should contain at least one group or its value will be
considered to be always empty.  Also, only the first match of regular
expression is processed.

The first group divides list of files into sub-groups, each of which is then
sorted by substrings extracted using second regular expression and so on
recursively.

Example: >
 set sortgroups=-(todo|done).*
this would group files with "-done" in their names and files with "-todo"
separately.  On ascending sorting, group containing "-done" would appear
before the other one.

                                               *vifm-'sortorder'*
sortorder
type: enumeration
default: ascending
scope: local

Sets sort order for primary key: ascending, descending.

                                               *vifm-'statusline'* *vifm-'stl'*
statusline stl
type: string
default: ""

Determines the content of the status line (the line right above command-line).
Empty string means use same format like in previous versions.  Following macros
are supported:
    %N - line break (increases height of the status line accordingly), ignores
         %[ %] blocks
    %t - file name (considering value of the |vifm-'classify'| option)
    %T - symbolic link target (empty for other filetypes)
    %f - file name relative to current directory (considers 'classify')
    %A - file attributes (permissions on *nix or properties on Windows)
    %o - file permissions in octal form on *nix (nothing on Windows)
    %u - user name or uid (if it cannot be resolved)
    %g - group name or gid (if it cannot be resolved)
    %s - file size in human readable format
    %E - size of selected files in human readable format, same as %s when no
         files are selected, except that it will never show size of ../ in
         visual mode, since it cannot be selected
    %d - file modification date (uses |vifm-'timefmt'| option)
    %D - path of the other pane for single-pane layout
    %a - amount of free space available on current FS
    %c - size of current FS
    %z - short tips/tricks/hints that chosen randomly after one minute period
    `%{<expr>}` - evaluate arbitrary vifm expression `<expr>`, e.g. `&sort` or
                `expand('%d')`; a raw `}` can be inserted as `\}` (mind that
                the slash doesn't need to be doubled to be inserted literally)
    %* - resets or applies one of User1..User20 highlight groups; reset happens
         when width field is 0 or not specified, one of the groups gets picked
         when width field is in the range from 1 to 20
    all |vifm-'rulerformat'| macros
Percent sign can be followed by optional minimum field width.  Add '-' before
minimum field width if you want field to be right aligned.

On Windows file properties include the following flags (upper case means flag
is on):
    A - archive
    H - hidden
    I - content isn't indexed
    R - readonly
    S - system
    C - compressed
    D - directory
    E - encrypted
    P - reparse point (e.g. symbolic link)
    Z - sparse file

Example without colors: >
 set statusline="  %t%= %A %10u:%-7g %15s %20d %{&sort} "

Example with colors: >
 highlight User1 ctermbg=yellow
 highlight User2 ctermbg=blue ctermfg=white cterm=bold
 set statusline="%1* %-26t %2* %= %1* %A %2* %7u:%-7g %1* %-5s %2* %d "
<
                                               *vifm-'suggestoptions'*
suggestoptions
type: string list
default:

Controls when, for what and how suggestions are displayed.  The following
values are available:
 - normal          - in normal mode;
 - visual          - in visual mode;
 - view            - in view mode;
 - otherpane       - use other pane to display suggestions, when available;
 - delay[:num]     - display suggestions after a small delay (to do not annoy
                     if you just want to type a fast shortcut consisting of
                     multiple keys), num specifies the delay in ms (500 by
                     default), |vifm-'timeoutlen'| at most;
 - keys            - include shortcuts (commands and selectors);
 - foldsubkeys     - fold multiple keys with common prefix;
 - marks           - include marks;
 - registers[:num] - include registers, at most num files (5 by default).

                                               *vifm-'syncregs'*
syncregs
type: string
default: ""

Specifies identifier of group of instances that share registers among each
other.  When several instances of vifm have this option set to identical
value, they automatically synchronize contents of their registers on
operations which use them.

                                               *vifm-'syscalls'*
syscalls
type: boolean
default: false

When disabled, vifm will rely on external applications to perform file-system
operations, otherwise system calls are used instead (much faster and supports
progress tracking).  The option should eventually be removed.  Mostly
*nix-like systems are affected.

                                               *vifm-'tablabel'*
tablabel
type: string
default: ""

When non-empty and |vifm-'tabline'| isn't set, determines format of the main
part of a single tab's label.

When empty, tab label is set to either tab name for named tabs or to view
title (usually current path) for unnamed tabs.

The following macros can appear in the format (see below for what a flag is):
    %C         - flag of a current tab
    %N         - number of the tab
    %T         - flag of a tree mode
    %c         - description of a custom view
    %n         - name of the tab
    %p         - path of the view (handles |vifm-filename-modifiers|)
    %t         - title of the view (affected by |vifm-'shortmess'| flags)
    %%         - literal percent sign
    %[         - designates beginning of an optional block
    %]         - designates end of an optional block
    %*, %0*    - resets highlighting
    %1* - %20* - applies one of User1..User20 highlight groups

In global tabs the view in bullets above refers to currently active view of that
tab.

Flag macros are a special kind of macros that always expand to an empty value
and are meant to be used inside optional blocks to control their visibility.

Optional blocks are ignored unless at least one macro inside of them is
expanded to a non-empty value or is a set flag macro.

Example: >
 " %[(%n)%]        -- optional name of the tab
 " %[              -- optional description of the view
 "   %[%T{tree}%]  -- mark of tree mode
 "   %[{%c}%]      -- description of custom view
 "   @             -- just an extra separator before the path
 ' %]
 " %p:t            -- tail part of view's location
 set tablabel=%[(%n)%]%[%[%T{tree}%]%[{%c}%]@%]%p:t
<
                                               *vifm-'tabline'* *vifm-'tal'*
tabline tal
type: string
default: ""

When non-empty, determines format of the tab line.  Note that mouse clicks
won't be handled when this option is non-empty.

The following macros can appear in the format:
    %*, %0*    - resets highlighting
    %1* - %20* - applies one of User1..User20 highlight groups

                                               *vifm-'tabprefix'*
tabprefix
type: string
default: "[%N:"

Determines prefix of a tab's label.  Formatting is done as for
|vifm-'tablabel'| option.

Example of highlighting tab number: >
 " setup color for non-current tabs
 highlight User7 ctermfg=red
 " setup color for current tabs
 highlight User8 ctermbg=blue ctermfg=none
 " use optional group predicated on current-tab flag
 set tabprefix=[%7*%[%8*%C%]%N%*:
<
                                               *vifm-'tabscope'*
tabscope
type: enumeration
default: global

Picks style of tabs, which defines what a single tab contains.  Possible
values:
 - global - tab describes complete UI of two views and how they are arranged
 - pane   - tab is located "inside" a pane and manages it and quick view

                                               *vifm-'tabstop'* *vifm-'ts'*
tabstop ts
type: integer
default: value from curses library

Number of spaces that a Tab in the file counts for.

                                               *vifm-'tabsuffix'*
tabsuffix
type: string
default: "]"

Determines suffix of a tab's label.  Formatting is done as for
|vifm-'tablabel'| option.

                                               *vifm-'timefmt'*
timefmt
type: string
default: "%m/%d %H:%M"

Format of time in file list.  See man date or man strftime for details.

                                               *vifm-'trash'*
trash
type: boolean
default: true

Use |vifm-trash| directory.

                                               *vifm-'trashdir'*
trashdir
type: string
default: on *nix:
           "%r/.vifm-Trash-%u,$XDG_DATA_HOME/vifm/Trash,%r/.vifm-Trash"
           or
           "%r/.vifm-Trash-%u,$VIFM/Trash,%r/.vifm-Trash"
         on Windows:
           "%r/.vifm-Trash,$XDG_DATA_HOME/vifm/Trash"
           or
           "%r/.vifm-Trash,$VIFM/vifm/Trash"

List of trash directory path specifications, separated with commas.
Each list item either defines an absolute path to |vifm-trash| directory
or a path relative to a mount point root, when list element starts with "%r/".
Value of the option can contain environment variables (of form "$envname"),
which will be expanded (prepend $ with a slash to prevent expansion).
Environment variables are expanded when the option is set.

On *nix, if element ends with "%u", the mark is replaced with real user ID and
permissions are set so that only that owner is able to use it.
Note that even this setup is not completely secure when combined with "%r/"
and it's overall safer to keep files in home directory, but that implies cost
of copying files between partitions.

When new file gets cut (deleted) vifm traverses each element of the option in
the order of their appearance and uses first trash directory that it was able
to create or that is already writable.

Default value tries to use trash directory per mount point and falls back to
trash common trash directory on failure.

Will attempt to create the directory if it does not exist.

                                               *vifm-'timeoutlen'* *vifm-'tm'*
timeoutlen tm
type: integer
default: 1000

The time in milliseconds that is waited for a mapped key in case when
already typed key sequence is ambiguous.  See also |vifm-'mintimeoutlen'|.

                                               *vifm-'title'*
title
type: boolean
default: true when title can be restored, false otherwise

When enabled, title of the terminal or terminal multiplexer's window is
updated according to current location.  Because not all terminals support
setting title, this works only if `$TERM` value matches one of the following
conditions:
 - equals "xterm" or starts with "xterm-"
 - equals "rxvt" or starts with "rxvt-"
 - equals "screen" or starts with "screen-"
 - equals "aterm"
 - equals "Eterm"

                                               *vifm-'tuioptions'* *vifm-'to'*
tuioptions to
type: charset
default: "psv"

Each flag configures some aspect of TUI appearance.  The flags are:
                                               *vifm-to-p*
p - when included:
  * file list inside a pane gets additional single character padding on left
    and right sides;
  * quick view and view mode get single character padding.
                                               *vifm-to-s*
s - when included, left and right borders (side borders, hence "s" character)
are visible.
                                               *vifm-to-u*
u - use Unicode characters in the TUI (Unicode ellipsis instead of "...").
                                               *vifm-to-v*
v - vary width of vertical middle border to equalize view sizes.

Each pane title contains the path of the listed directory.  If too large, the
path is truncated on the left for the active pane and on the right for the other
pane.  This can be modified with:
                                               *vifm-to-l*
l - truncation is always on the left.
                                               *vifm-to-r*
r - truncation is always on the right.

                                               *vifm-'uioptions'*
uioptions
type: set
default:

Tweaks UI behaviour.  The following values are available:
 - iodetails - show I/O progress details dialog automatically instead of
               displaying progress on statusbar until user presses "i" to see
               the dialog.

                                               *vifm-'undolevels'* *vifm-'ul'*
undolevels ul
type: integer
default: 100

Maximum number of changes that can be undone.  Note that here single file
operation is used as a unit, not operation, i.e. deletion of 101 files will
exceed default limit.

                                               *vifm-'vicmd'*
vicmd
type: string
default: "vim"

Command used to edit files in various contexts.  Ampersand sign at the end
(regardless whether it's preceded by space or not) means backgrounding of
command.

Background flag is ignored in certain context where vifm waits for the editor
to finish.  Such contexts include any command that spawns editor to change
list of file names or a command, with |vifm-:rename| being one example.
`-f` is also appended to prevent forking in such cases, so the command needs
to handle the flag.

Additionally `+{num}` and `+'call cursor()'` arguments are used to position
cursor when location is known.

                                               *vifm-'viewcolumns'*
viewcolumns
type: string
default: ""
scope: local

Format string containing list of columns in the view.  When this option is
empty, view columns to show are chosen automatically using sorting keys
(see |vifm-'sort'|) as a base.  Value of this option is ignored if
|vifm-'lsview'| is set.  See |vifm-column-view| for format description.
An example of setting the options for both panes (note |vifm-:windo|
command): >
    windo set viewcolumns=-{name}..,6{size},11{perms}
<
                                               *vifm-'vixcmd'*
vixcmd
type: string
default: value of |vifm-'vicmd'|

Same as |vifm-'vicmd'|, but takes precedence over it when running inside a
graphical environment.

                                               *vifm-'vifminfo'*
vifminfo
type: set
default: bookmarks,bmarks

Controls what will be saved in the $VIFM/vifminfo file:

   bmarks    - named bookmarks (see |vifm-:bmark|)
   bookmarks - marks, except for special ones like '< and '>
   cs        - primary color scheme
   dirstack  - directory stack (overwrites previous stack, unless stack of
               current instance is empty)
   registers - registers content
   savedirs  - last visited directory
   state     - file name and dot filters and terminal multiplexers integration
               state
   tabs      - global or pane tabs
   tui       - state of the user interface (sorting, number of windows, quick
               view state, active view)

   chistory  - command line history
   dhistory  - directory history
   ehistory  - expression register history (see |vifm-c_CTRL-R_=|)
   fhistory  - history of local filter (see |vifm-=|)
   mchistory - command line history of menus
   phistory  - prompt history
   shistory  - search history (/ and ? commands)

   commands  - user defined commands (see :command description) (obsolete)
   filetypes - associated programs and viewers (obsolete)
   options   - all options that can be set with the :set command (obsolete)

                                               *vifm-'vimhelp'*
vimhelp
type: boolean
default: false

Use vim help format.

                                               *vifm-'wildinc'*
wildinc
type: string
default:""

A comma-separated list of globs which defines what should be completed
incrementally.  Currently, it can only be :commands which are matched with the
colon in front of their name.  For such commands completion is always active
and is displayed even if there is only one completion item.  Examples: >
    " for all :commands
    set wildinc=:*
    " only for these two
    set wildinc=:wingo,:bmgo

See |vifm-patterns| and |vifm-globs| for more information on syntax.

                                               *vifm-'wildmenu'* *vifm-'wmnu'*
wildmenu wmnu
type: boolean
default: false

Controls whether possible matches of completion will be shown above the
command line.

                                               *vifm-'wildstyle'*
wildstyle
type: enumeration
default: bar

Picks presentation style of wild menu.  Possible values:
 - bar   - one-line with left-to-right cursor
 - popup - multi-line with top-to-bottom cursor

                                               *vifm-'wordchars'*
wordchars
type: string list
default: "1-8,14-31,33-255" (that is all non-whitespace characters)

Specifies which characters in command-line mode should be considered as part
of a word.  Value of the option is comma-separated list of ranges.  If both
endpoints of a range match, single endpoint is enough (e.g. "a" = "a-a").
Both endpoints are inclusive.  There are two accepted forms: character
representing itself or number encoding character according to ASCII table.
In case of ambiguous characters (dash, comma, digit) use numeric form.
Accepted characters are in the range from 0 to 255.  Any Unicode character
with code greater than 255 is considered to be part of a word.

The option affects |vifm-c_ALT-D|, |vifm-c_ALT-B| and |vifm-c_ALT-F|, but not
|vifm-c_CTRL-W|.  This is intentionally to allow two use cases:

 - Moving by WORDS and deletion by words.
 - Moving by words and deletion by WORDS.

To get the later use the following mapping: >
    cnoremap <c-w> <a-b><a-d>
<
Also used for abbreviations.

                                               *vifm-'wrap'*
wrap
type: boolean
default: true

Controls whether to wrap text in quick view.

                                               *vifm-'wrapscan'* *vifm-'ws'*
wrapscan ws
type: boolean
default: true

Searches wrap around end of the list.

--------------------------------------------------------------------------------
*vifm-mappings*

A user mapping like `nnoremap lhs rhs` defines a substitution of the
left-hand-side (LHS) with the right-hand-side (RHS) in the input stream.  A
regular mapping (without "nore" in :command's name) expands recognized
sequences in the RHS, while "*noremap" mapping always interprets RHS as if no
user mappings were defined and each key has its builtin meaning.  In most
cases you want to use noremap variant and if your RHS includes LHS, only
noremap variant will work because recursion in a mapping is not allowed.

In order to define a mapping determine in which mode you want to activate it
and use an appropriate "*noremap" :command (e.g., |vifm-:nnoremap| for a
normal mode mapping).  RHS doesn't have to limit itself to the mode in which
the mapping was started and can span multiple modes.

Map arguments~

LHS of mappings can be preceded by arguments which take the form of special
sequences:

<silent>                                       *vifm-:map-<silent>*
    Postpone UI updates until RHS is completely processed.
<wait>                                         *vifm-:map-<wait>*
    In case of builtin mapping causing conflict for a user-defined mapping
    (e.g., `t` builtin to a partially typed `ta` user-defined mapping), ignore
    the builtin mapping and wait for input indefinitely as opposed to
    default behaviour of triggering the builtin mapping after a delay defined
    by |vifm-'timeoutlen'|.  Example: >
        nnoremap <wait> tw :set wrap!<cr>
        nnoremap <wait> tn :set number!<cr>
        nnoremap <wait> tr :set relativenumber!<cr>

Special sequences~

Since it's not easy to enter special characters there are several special
sequences that can be used in place of them.  They are:

<cr>
    Enter key.
<esc>
    Escape key.
<space>
    Space key.
<lt>
    Less-than character (<).
<nop>
    provides a way to disable a mapping (by mapping it to <nop>).
<bs>
    Backspace key (see key conflict description below).
<tab> <s-tab>
    Tabulation and Shift+Tabulation keys.
<home> <end>
    Home/End.
<left> <right> <up> <down>
    Arrow keys.
<pageup> <pagedown>
    PageUp/PageDown.
<del> <delete>
    Delete key.  <del> and <delete> mean different codes, but <delete> is
    more common.
<insert>
    Insert key.
<s-home> <s-end>
<s-left> <s-right> <s-up> <s-down>
<s-pageup> <s-pagedown>
<s-delete> <s-insert>
    Shift + one of the keys from above, if terminal and its terminfo supports
    it.
<c-a>,<c-b>,...,<c-z>,<c-[>,<c-\>,<c-]>,<c-^>,<c-_>
    Control + some key (see key conflict description below).
<c-@>                                          {only for *nix}
    Control + Space.
<a-a>,<a-b>,...,<a-z>
<m-a>,<m-b>,...,<m-z>
<a-0>,<a-1>,...,<a-9>                          {only for *nix}
<m-0>,<m-1>,...,<m-9>                          {only for *nix}
    Alt + some key.
<a-c-a>,<a-c-b>,...,<a-c-z>                    {only for *nix}
<m-c-a>,<m-c-b>,...,<m-c-z>                    {only for *nix}
    Alt + Ctrl + some key.
<a-s-a>,<a-s-b>,...,<a-s-z>                    {only for *nix}
<s-a-a>,<s-a-b>,...,<s-a-z>                    {only for *nix}
<m-s-a>,<m-s-b>,...,<m-s-z>                    {only for *nix}
<s-m-a>,<s-m-b>,...,<s-m-z>                    {only for *nix}
    Alt + Shift + some key.
<f0> - <f63>
    functional keys.  These also correspond to keys like <c-f1> and can be
    used in their place.
<c-f1>,...,<c-f12>
    functional keys with Control key pressed.
<a-f1>,...,<a-f12>, <m-f1>,...,<m-f12>
    functional keys with Alt key pressed.
<s-f1>,...,<s-f12>
    functional keys with Shift key pressed.

Note that whether and how functional keys work might depend on the terminal
and corresponding terminfo record.

Note that due to the way terminals process their input, several keyboard keys
might be mapped to single key code, for example:
 - <cr> and <c-m>;
 - <tab> and <c-i>;
 - <c-h> and <bs> and <del>;
 - etc.

Most of the time they are defined consistently and don't cause surprises, but
<c-h> and <bs> are treated differently in different environments (although they
match each other all the time), that's why they correspond to different keys
in vifm.  As a consequence, if you map <c-h> or <bs> be sure to repeat the
mapping with the other one so that it works in all environments.
Alternatively, provide your mapping in one form and add one of the following: >
  " if mappings with <c-h> in the LHS work
  map <c-h> <bs>
  " if mappings with <bs> in the LHS work
  map <bs> <c-h>

Also sometimes neither of them might work and it's <del> key which corresponds
to your backspace (don't mind the name).

Whitespace~

vifm removes whitespace characters at the beginning and end of commands.
That's why you may want to use <space> at the end of rhs in mappings.  For
example: >
 cmap <f1> man<space>
will put "man " in line when you hit the <f1> key in the command line mode.

--------------------------------------------------------------------------------
*vifm-expression-syntax*

Supported expressions is a subset of what VimL provides.

Expression syntax summary, from least to most significant:

|vifm-expr1| expr2
           expr2 || expr2 ..       logical OR

|vifm-expr2| expr3
           expr3 && expr3 ..       logical AND

|vifm-expr3| expr4
           expr4 == expr4          equal
           expr4 != expr4          not equal
           expr4 >  expr4          greater than
           expr4 >= expr4          greater than or equal
           expr4 <  expr4          smaller than
           expr4 <= expr4          smaller than or equal

|vifm-expr4| expr5
           expr5 + expr5 ..        number addition
           expr5 - expr5 ..        number subtraction

|vifm-expr5| expr6
           expr6 . expr6 ..        string concatenation

|vifm-expr6| expr7
           - expr6                 unary minus
           + expr6                 unary plus
           ! expr6                 logical NOT

|vifm-expr7| number                  number constant
           "string"                string constant, backslash is special
           'string'                string constant, ' is doubled
           &option                 option value
           $VAR                    environment variable
           g:var                   global variable
           v:var                   builtin variable (read-only)
           function(expr1, ...)    function call
           (expr1)                 nested expression

".." indicates that the operations in this level can be concatenated.

expr1                                          *vifm-expr1*
-----
expr2 || expr2

Arguments are converted to numbers before evaluation.

Result is non-zero if at least one of arguments is non-zero.

It's right associative and with short-circuiting, so sub-expressions are
evaluated from left to right until result of whole expression is determined
(i.e., until first non-zero) or end of the expression.

expr2                                          *vifm-expr2*
-----
expr3 && expr3

Arguments are converted to numbers before evaluation.

Result is non-zero only if both arguments are non-zero.

It's right associative and with short-circuiting, so sub-expressions are
evaluated from left to right until result of whole expression is determined
(i.e., until first zero) or end of the expression.

expr3                                          *vifm-expr3*
-----
expr4 {cmp} expr4

Compare two expr4 expressions, resulting in a 0 if it evaluates to false or 1
if it evaluates to true.

equal                   ==                     *vifm-expr-==*
not equal               !=                     *vifm-expr-!=*
greater than            >                      *vifm-expr->*
greater than or equal   >=                     *vifm-expr->=*
smaller than            <                      *vifm-expr-<*
smaller than or equal   <=                     *vifm-expr-<=*

Examples: >
  'a' ==  'a'         == 1
  'a' >   'b'         == 1
  'a' ==  'b'         == 0
  '2' >   'b'         == 0
   2  >   'b'         == 1
   2  >   '1b'        == 1
   2  >   '9b'        == 0
  -1  == -'1'         == 1
   0  ==  '--1'       == 1
<

expr4                                          *vifm-expr4*
-----
expr5 + expr5 ..     number addition           *vifm-expr-+*
expr5 - expr5 ..     number subtraction        *vifm-expr--*

Examples: >
  1 + 3 - 3          == 1
  1 + '2'            == 3
<

expr5                                          *vifm-expr5*
-----
expr6 . expr6 ..     string concatenation      *vifm-expr-.*

Examples: >
  'a' . 'b'          == 'ab'
  'aaa' . '' . 'c'   == 'aaac'
<

expr6                                          *vifm-expr6*
-----

- expr6              unary minus               *vifm-expr-unary--*
+ expr6              unary plus                *vifm-expr-unary-+*
! expr6              logical NOT               *vifm-expr-unary-!*

For '-' the sign of the number is changed.
For '+' the number is unchanged.
For '!' non-zero becomes zero, zero becomes one.

A String will be converted to a Number first.

These operations can be repeated and mixed.  Examples: >
   --9               == 9
  ---9               == -9
   -+9               == 9
   !-9               == 0
   !''               == 1
  !'x'               == 0
   !!9               == 1
<

expr7                                          *vifm-expr7*
-----

number               number constant           *vifm-expr-number*
------

Decimal number.  Examples: >
  0                  == 0
  0000               == 0
  01                 == 1
  123                == 123
  10000              == 10000
<
string                                         *vifm-expr-string*
------
"string"             string constant           *vifm-expr-quote*

Note that double quotes are used.

A string constant accepts these special characters:
\b      backspace <bs>
\e      escape <esc>
\n      newline
\r      return <cr>
\t      tab <tab>
\\      backslash
\"      double quote

Examples: >
  "\"Hello,\tWorld!\""
  "Hi,\nthere!"
<

literal-string                                 *vifm-literal-string*
--------------
'string'              string constant          *vifm-expr-'*

Note that single quotes are used.

This string is taken as it is.  No backslashes are removed or have a special
meaning.  The only exception is that two quotes stand for one quote.

Examples: >
  'All\slashes\are\saved.'
  'This string contains doubled single quotes ''here'''
<

option                                         *vifm-expr-option*
------
&option               option value (local one is preferred, if exists)
&g:option             global option value
&l:option             local option value

Examples: >

  echo 'Terminal size: '.&columns.'x'.&lines
  if &columns > 100
<
Any valid option name can be used here (note that "all" in ":set all" is a
pseudo option).  See |vifm-set-options|.


environment variable                           *vifm-expr-env*
--------------------
$VAR                  environment variable

The String value of any environment variable.  When it is not defined, the
result is an empty string.

Examples: >
  'This is my $PATH env: ' . $PATH
  'vifmrc at ' . $MYVIFMRC . ' is used.'
<

                                               *vifm-expr-variable*
global variable
---------------
g:var                 global variable

A typed storage of data for use in scripting.  Can be created/removed
dynamically (via |vifm-:let| and |vifm-:unlet|) and used in expressions.

builtin variable
----------------
v:var                 builtin variable (read-only)

Information exposed by vifm for use in scripting.  Such variables are
predefined and read-only, but not necessarily constant.

                                               *vifm-v:count*
v:count                                        *vifm-count-variable*
    count passed to : command.  Can be used in mappings to pass count
    to a different command.

                                               *vifm-v:count1*
v:count1                                       *vifm-count1-variable*
    same as v:count, but 1 by default.

                                               *vifm-v:jobcount*
v:jobcount                                     *vifm-jobcount-variable*
    number of active jobs (as can be seen in the |vifm-:jobs| menu).

                                               *vifm-v:session*
v:session                                      *vifm-session-variable*
    name of the current session or empty string.

                                               *vifm-v:version*
v:version                                      *vifm-version-variable*
    version of the application as an integer.  Version `x.y.z` becomes number
    `x*100*100 + y*100 + z`, examples:
     - v0.14 (that is v0.14.0) is 1400 (leading zeroes omitted)
     - v1.0.2 is 10002

    Release candidates aren't real releases, they report the number of a
    corresponding release.

See also |vifm-v:servername|.

function call                                  *vifm-expr-function*
-------------
function(expr1, ...)  function call

See below |vifm-functions|.

Examples: >
  "'" . filetype('.') . "'"
  filetype('.') == 'reg'
<
expression nesting                             *vifm-expr-nesting*
------------------
(expr1)               nested expression

Groups any other expression of arbitrary complexity enforcing order in which
operators are applied.

--------------------------------------------------------------------------------
*vifm-functions*

USAGE                 RESULT      DESCRIPTION	~

chooseopt({opt})      String      Queries choose parameters passed on startup.
escape({string}, {chars})
                      String      Returns {string} after escaping {chars} in it.
executable({expr})    Integer     Checks whether {expr} command available.
expand({expr})        String      Expands special keywords in {expr}.
extcached({cache}, {path}, {extcmd})
                      String      Caches output of {extcmd} per {cache} and
                                  {path} combination.
filereadable({path})  Integer     Checks whether {expr} points to a
                                  non-directory that can be read.
filetype({file} [, {resolve}])
                      String      Returns file type from position/path.
fnameescape({expr})   String      Escapes {expr} for use in a :command.
getpanetype()         String      Returns type of current pane.
has({property})       Integer     Checks whether instance has {property}.
input({prompt} [, {initial} [, {completion}]])
                      String      Prompts user for an input on command-line.
layoutis({type})      Integer     Checks whether layout is of type {type}.
paneisat({loc})       Integer     Checks whether current pane is at {loc}.
selected()            Integer     Returns number of currently selected files.
system({command})     String      Executes shell command and returns its output.
tabpagenr([{arg}])    Integer     Returns number of current or last tab.
term({command})       String      Like system(), but for interactive commands.


chooseopt({opt})                               *vifm-chooseopt()*

Retrieves values of options related to file choosing.  {opt} can be one of:
    files      returns argument of |vifm---choose-files| or empty string
    dir        returns argument of |vifm---choose-dir| or empty string
    cmd        returns argument of |vifm---on-choose| or empty string
    delimiter  returns argument of |vifm---delimiter| or the default one ("\n")

escape({string}, {chars})                      *vifm-escape()*

Escapes all occurrences of {chars} in the {string} by prepending slash (`\`) to
them.  Note that the slash itself is not escaped unless it appears in {chars}.

executable({expr})                             *vifm-executable()*

If {expr} is absolute or relative path, checks whether path destination exists
and refers to an executable, otherwise checks whether command named {expr} is
present in directories listed in $PATH.  Checks for various executable
extensions on Windows.  Returns boolean value describing result of the check.

Example: >
  " use custom default viewer script if it's available and installed
  " in predefined system directory, otherwise try to find it elsewhere
  if executable('/usr/local/bin/defviewer')
      fileview * /usr/local/bin/defviewer %c
  else
      if executable('defviewer')
          fileview * defviewer %c
      endif
  endif

expand({expr})                                 *vifm-expand()*

Expands environment variables and macros in {expr} (in this order).  Returns
a string.  See |vifm-macros|.

Examples: >
  " percent sign
  :echo expand('%%')
  " the last part of directory name of the other pane
  :echo expand('%D:t')
  " $PATH environment variable (same as `:echo $PATH`)
  :echo expand('$PATH')
  " full path to the current file with backslashes
  :echo expand('%c:p:gs!/!\\!')

extcached({cache}, {path}, {extcmd})           *vifm-extcached()*

Caches value of {extcmd} external command automatically updating it as
necessary based on monitoring change date of a {path}.  The cache is
invalidated when file or its meta-data is updated.  A single path can have
multiple caches associated with it.

{path} value is normalized, but symbolic links in it aren't resolved.

Example: >
  " display number and size of blocks actually used by a file or directory
  set statusline+=" Uses: %{ extcached('uses',
                                     \ expand('%c'),
                                     \ expand('stat --format=%%bx%%B %c')) }"

filereadable({path})                           *vifm-filereadable()*

Checks whether {path} exists and refers to a non-directory entry and its
permissions allow reading.  Returns boolean value describing result of the
check.

filetype({file} [, {resolve}])                 *vifm-filetype()*

Checks type of a view's entry or of a file specified by its path.

Parameter {file} can be of the following forms:
 - '.' to get type of file under the cursor in the active pane
 - numerical value base 1 to get type of file on specified line number (only
   if there are no characters other than "+-0123456789")
 - a path (prepend "./" to force interpretation of a number or '.' as a path)

Optional parameter {resolve} is treated as a boolean and specifies whether
symbolic links should be resolved.

The result is a string, which represents file type and is one of the list:
    exe     executables
    reg     regular files
    link    symbolic links
    broken  broken symbolic links (appears only when resolving)
    dir     directories
    char    character devices
    block   block devices
    fifo    pipes
    sock    *nix domain sockets
    ?       unknown file type (should not normally happen) or
            non-file (pseudo-entries in compare view)

The result can also be an empty string in case of invalid argument.

fnameescape({expr})                            *vifm-fnameescape()*

Escapes parameter to make it suitable for use as an argument of a :command.
List of escaped characters includes %, which is doubled.

Usage example: >
  " navigate to most recently modified file in current directory
  execute 'goto' fnameescape(system('ls -t | head -1'))

getpanetype()                                  *vifm-getpanetype()*

Retrieves string describing type of current pane.  Possible return values:
    regular      regular file listing of some directory
    custom       custom file list (%u)
    very-custom  very custom file list (%U)
    tree         tree view
    compare      compare view

has({property})                                *vifm-has()*

Allows examining internal parameters from scripts to e.g. figure out
environment in which application is running.  Returns 1 if property is
true/present, otherwise 0 is returned.  Currently the following properties
are supported (anything else will yield 0):
    unix  runs in *nix-like environment (including Cygwin)
    win   runs on Windows
    #*    whether particular Lua handler exists (|vifm-lua-handlers|)

Usage example: >
  " skip user/group on Windows
  if !has('win')
      let $RIGHTS = '%10u:%-7g '
  endif

  execute 'set' 'statusline="  %t%= %A '.$RIGHTS.'%15E %20d  "'

input({prompt} [, {initial} [, {completion}]]) *vifm-input()*

Creates a command-line prompt to obtain user's input.  Initial value can
be supplied as an optional second parameter, otherwise empty string is used.

Optional third parameter specifies kind of completion, which can be one of:
    dir   paths to directories
    file  paths to files and directories
    ""    (empty string, default) no completion

Note that behaviour differs from Vim where executing a mapping like >
  nnoremap j :echo input('text: ')<cr>input
leaves you in a prompt mode with "input" typed in.  Vifm will wait for leaving
the prompt and then continue executing the mapping.

Usage example: >
  nnoremap ,m : let $DIR_NAME = input('mkdir: ', '', 'dir')
             \| if $DIR_NAME != ''
             \|     execute 'mkdir' fnameescape($DIR_NAME)
             \| endif<cr>

layoutis({type})                               *vifm-layoutis()*

Checks whether current interface layout is {type} or not, where {type} can
be:
    only    single-pane mode
    split   double-pane mode (either vertical or horizontal split)
    vsplit  vertical split (left and right panes)
    hsplit  horizontal split (top and bottom panes)

Any other value yields 0.

Usage example: >
  " automatically split vertically before enabling preview
  :nnoremap w :if layoutis('only') | vsplit | endif | view!<cr>

paneisat({loc})                                *vifm-paneisat()*

Checks whether position of active pane in current layout matches one of the
following locations:
    top     pane reaches top border
    bottom  pane reaches bottom border
    left    pane reaches left border
    right   pane reaches right border

selected()                                     *vifm-selected()*

Retrieves number of files selected in the active pane.

system({command})                              *vifm-system()*

Runs the command in shell and returns its output (joined standard output and
standard error streams).  All trailing newline characters are stripped to
allow easy appending to command output.  CTRL-C should interrupt the command.

Use this function to consume output of external commands that don't require
user interaction and term() for interactive commands that can make use of
terminal and are capable of handling stream redirection.

Usage example: >
  " command to enter .git/ directory of git-repository (when ran inside one)
  command! cdgit :execute 'cd' fnameescape(system('git rev-parse --git-dir'))

tabpagenr([{arg}])                             *vifm-tabpagenr()*

When called without arguments returns number of current tab page base one.

When called with `"$"` as an argument returns number of the last tab page base
one, which is the same as number of tabs.

term({command})                                *vifm-term()*

Same as system() function, but user interface is shutdown during the execution
of the command, which makes sure that external interactive applications won't
affect the way terminal is used by vifm.

Usage example: >
  " command to change directory by picking it via fzf
  command! fzfcd :execute 'cd'
                        \ fnameescape(term('find -type d | fzf 2> /dev/tty'))

--------------------------------------------------------------------------------
*vifm-menus-and-dialogs*

When navigating to some path from a menu there is a difference in the end
location depending on whether the path has a trailing slash.  Files normally
don't have trailing slashes so "file/" won't work.  In case of directories
there are two options: navigate to a directory or inside of it.  To allow both
use cases, the first action is taken for "dir" and the second one for "dir/".

Menu commands~

:range                                         *vifm-m_:range*
    navigate to a menu line.

                                               *vifm-m_:chistory* *vifm-:m_chi*
:chi[story]
    display menu of saved menus.  See |vifm-menus-and-dialogs| for controls,
    also see |vifm-menus-history|.
:col[der]                                      *vifm-m_:colder* *vifm-m_:col*
    load an older navigation menu if there is one.
    See |vifm-menus-history|.
:cnew[er]                                      *vifm-m_:cnewer* *vifm-m_:cnew*
    load a newer navigation menu if there is one.
    See |vifm-menus-history|.

                                               *vifm-m_:find* *vifm-m_:fin*
:fin[d] pattern
:fin[d] -opt...
:fin[d] path -opt...
:fin[d]
    the behaviour matches that of non-menu |vifm-:find| except that no range is
    accepted.  If active view contained selection before entering menu mode,
    the command takes it into account.
                                               *vifm-m_:grep* *vifm-m_:gr*
:gr[ep][!] pattern
:gr[ep][!] -opt...
:gr[ep][!]
    the behaviour matches that of non-menu |vifm-:grep| except that no range is
    accepted.  If active view contained selection before entering menu mode,
    the command takes it into account.

:exi[t][!]                                     *vifm-m_:exit* *vifm-m_:exi*
:q[uit][!]                                     *vifm-m_:quit* *vifm-m_:q*
:x[it][!]                                      *vifm-m_:xit*  *vifm-m_:x*
    leave the menu mode.

:noh[lsearch]                                  *vifm-m_:nohlsearch*
                                               *vifm-m_:noh*
    reset search match highlighting.

:w[rite] {path}                                *vifm-m_:write* *vifm-m_:w*
    write all menu lines into the file specified by {path}.

Common keys of all menus and dialogs~

j, Ctrl-N                                      *vifm-m_j* *vifm-m_CTRL-N*
    move the cursor down.
k, Ctrl-P                                      *vifm-m_k* *vifm-m_CTRL-P*
    move the cursor up.

Enter                                          *vifm-m_Enter*
    select and usually close menu/dialog.
Ctrl-L                                         *vifm-m_CTRL-L*
    redraw menu/dialog.

Escape, Ctrl-C                                 *vifm-m_Escape* *vifm-m_CTRL-C*
ZZ, ZQ                                         *vifm-m_ZZ* *vifm-m_ZQ*
q                                              *vifm-m_q*
    close menu/dialog.

Common keys of all menus~

Ctrl-B, Ctrl-F                                 *vifm-m_CTRL-B* *vifm-m_CTRL-F*
Ctrl-D, Ctrl-U                                 *vifm-m_CTRL-D* *vifm-m_CTRL-U*
Ctrl-E, Ctrl-Y                                 *vifm-m_CTRL-E* *vifm-m_CTRL-Y*
/, ?                                           *vifm-m_/* *vifm-m_?*
n, N                                           *vifm-m_n* *vifm-m_N*
[count]G, [count]gg                            *vifm-m_G* *vifm-m_gg*
H, M, L                                        *vifm-m_H* *vifm-m_M* *vifm-m_L*
zb, zt, zz                                     *vifm-m_zb* *vifm-m_zt*
                                               *vifm-m_zz*
    these keys have the same meaning as in normal mode.

[count]zh                                      *vifm-m_zh*
    scroll menu items [count] characters (1 by default) to the right.
[count]zl                                      *vifm-m_zl*
    scroll menu items [count] characters (1 by default) to the left.

zH                                             *vifm-m_zH*
    scroll menu items half the screen width to the right.
zL                                             *vifm-m_zL*
    scroll menu items half the screen width to the left.


:   enter command line mode for menus.         *vifm-m_:*


b                                              *vifm-m_b*
    interpret content of the menu as a list of paths and use it to create
    custom view in place of the previously active pane.  See
    |vifm-custom-views|.
B                                              *vifm-m_B*
    same as above, but create an unsorted view.


v                                              *vifm-m_v*
    load menu content into quickfix list of an editor (Vim compatible by
    assumption) or, if the list doesn't have separators after file
    names (colons), open each line as a file name.

Navigation menus~

This applies to the following menus:
 - |vifm-:bmarks|, |vifm-:bmgo|
 - |vifm-:find|
 - |vifm-:grep|
 - |vifm-:locate|
 - user menu with navigation (|vifm-%M|)

gf                                             *vifm-m_gf*
    navigate previously active view to currently selected item.  Leaves menu
    mode except for |vifm-:grep| menu.  Pressing Enter or l has the same
    effect.

e                                              *vifm-m_e*
    open selected path in an editor, stays in menu mode.

c                                              *vifm-m_c*
    leave menu preserving file selection and insert file name after :! in
    command-line mode.  Does nothing in |vifm-:bmarks| and |vifm-:bmgo|.

Note that each of these menus can have additional keys, see below.

History menus (:history *)~
==========================

Command-line history menu~

Enter, l
    execute the item as a command-line command, search query or local filter.
c
    leave the menu preserving file selection and insert the item into
    the command-line of appropriate kind.

Directory history menu~

Enter, l
    navigate into the selected directory.

Menu commands history menu~

Enter, l
    execute command without leaving the menu.
c
    insert menu item into the command-line for editing.

Other menus~
===========

Apropos (:apropos) menu~

Enter, l
    run man on a given topic.  Menu won't be closed automatically to allow
    viewing several pages one by one.

Bookmarks (:bmarks, :bmgo) menu~

Enter, l
    navigate to the selected bookmark.
dd
    remove bookmark under the cursor.

See above for "gf" and "e" keys.

Command-line mode abbreviations (:cabbrev) menu~

dd
    remove abbreviation under the cursor.

Color scheme (:colorscheme) menu~

Enter, l
    apply selected colorscheme as if ":colorscheme <name>" was executed on the
    command-line.

Commands (:command) menu~

Enter, l
    execute the command with empty arguments (|vifm-%a|).
dd
    remove command under the cursor.
c
    leave menu preserving file selection and insert right-hand side of selected
    command into the command-line.

Directory stack (:dirs) menu~

Enter, l
    rotate the stack to put selected directory pair at the top.

File (:file) menu~

Commands from vifmrc or typed on the command-line are displayed above an empty
line if it's present.  All commands below the empty line come from .desktop
files.

Commands detected as available have "[present]" to the left of them.

Enter, l
    run selected command (regardless whether it was detected to be present or
    not).
c
    leave menu preserving file selection and insert command after :! in the
    command-line mode.

Grep (:grep) menu~

Enter, l
    open file in an editor set by |vifm-'vicmd'| at given line number.  Menu
    won't be closed automatically to allow viewing more than one result.

See above for "gf", "e" and "c" keys.

Jobs (:jobs) menu~

dd
    request cancellation of job under the cursor.  The job won't be removed
    from the list, but marked as being cancelled (if cancellation was
    successfully requested).  A message will pop up if the job has already
    stopped.  Note that on Windows cancelling external programs like this might
    not work, because their parent shell doesn't have any windows.
e
    display errors of selected job if any were collected.  They are
    displayed in a new menu, but you can return to jobs menu by pressing h.
r
    reload the list of jobs.

Marks (:marks) menu~

Enter, l
    navigate to selected mark.
dd
    remove mark under the cursor.

Media (:media) menu~

Enter, l
    behaviour is different for different kinds of lines:
     - mount an unmounted device
     - navigate to the first mount point of a mounted device
     - navigate to a mount point
     - do nothing for "not mounted" or an empty line

r
    reload the list.
m
    mount/unmount device (cursor should be positioned on lines under device
    information).
[
    put cursor on the previous device.
]
    put cursor on the next device.

Menus history (:chistory) menu~

Enter, l
    load selected menu.

Plugins (:plugins) menu~

e
    display log messages of selected plugin if any were collected.  They are
    displayed in a new menu, but you can return to plugins menu by pressing h.
gf
    navigate previously active view to the location of selected plugin.
    Leaves menu mode.

Trash (:lstrash) menu~

r
    restore a file from the trash to its original location.
dd
    delete file under the cursor.

Trashes (:trashes) menu~

Enter, l
    navigate into current trash directory.
dd
    start emptying selected trash in background.

Undolist (:undolist) menu~

r
    reset undo position to group under the cursor.

User menu without navigation (%m macro)~

c
    leave menu preserving file selection and insert whole line after :! in
    command-line mode.

Volumes (:volumes) menu~
                                               {only for MS-Windows}
Enter, l
    navigate into the root of selected drive.

Dialog-specific operations~
==========================

Attributes (permissions or properties) dialog~

h, Space
    check/uncheck.
q
    close the dialog.
r
    (*nix only) (un)set all read bits.
w
    (*nix only) (un)set all write bits.
x
    (*nix only) (un)set all execute bits.
s
    (*nix only) (un)set all special (SetUID, SetGID, Sticky) bits.
e
    (*nix only) (un)set recursion (for directories only).

Possible item states:
 * - checked flag.
 X - selected files have inconsistent value of this flag.
                                                {only for *nix}
 d - (only for execute flags) means u-x+X, g-x+X or o-x+X argument for the
     chmod program.  If you're not on OS X and want to remove execute permission
     bit from all files, but preserve it for directories, set all execute flags
     to 'd' and check 'Set Recursively' flag.

Fileinfo (Ctrl-G) dialog~

Enter, q
    close the dialog.

Sort (:sort) dialog ~

h, Space
    switch ascending/descending order.
q
    close the dialog.

There is also a shortcut per sorting key (drawn on the dialog).

--------------------------------------------------------------------------------
*vifm-menus-history*

Menus are often used to present results of operations (like finding or grepping
files).  Once closed they can be recreated by repeating a command, but it
might be inconvenient (require changing directory, finding the command and
possibly finding position in a menu) and time consuming to re-run the
operation.  To make referring to older menus possible, vifm stores up to 25
last such menus and provides means for recalling them using familiar set of
Vim commands.

As already hinted above, this doesn't apply to every menu because things like
|vifm-:version| or |vifm-:command| rely solely on internal data and don't
need to be saved.  Only menus that are derived from external sources and
support navigation (like via |vifm-m_gf|) are remembered.

Navigating through history~

Re-opening the last viewed menu of relevant type is done by running
|vifm-:copen| command.  Once opened |vifm-m_:colder| can be used to view older
menus and |vifm-m_:cnewer| to view newer ones.

Closing a menu after moving through the history remembers the position such
that running |vifm-:copen| again will open the last viewed menu and allow one
to continue exploring history in both directions.

The history always contains menus sorted from oldest to newest.  After opening
more than 25 menus the oldest one is likely to be forgotten.  It's not
guaranteed to happen because after viewing an older menu new entry replaces
all more recent ones.  As an example, assume the history looks like this:

 1. `:find 1`
 2. `:find 2`
 ...
23. `:find 23` (current element)
24. `:find 24`
25. `:find 25`

Running `:find 26` results in:

 1. `:find 1`
 2. `:find 2`
 ...
23. `:find 23`
24. `:find 26` (current element)
25. None

For convenience, |vifm-m_:colder| and |vifm-m_:cnewer| can be used any time
you're in a menu, not just after |vifm-:copen|.  :cnewer will work only if
current menu can't be saved and you've moved back in menus history before.
Behaviour of :colder is like this:
 - if current menu can be stashed, behave as |vifm-m_:quit|, :copen, :colder
   sequence (current menu is stashed the same way as described above)
 - if current menu can't be stashed, behave as |vifm-m_:quit|, :copen sequence

Viewing history~

In order to avoid enumerating menus looking for the matching one,
|vifm-:chistory| command can be used to get an overview of saved menus,
maybe search for one and then open it.  The command is also available in menu
mode (|vifm-m_:chistory|).

Related topics~

Commands: |vifm-:chistory|, |vifm-:copen|
Menu commands: |vifm-m_:chistory|, |vifm-m_:colder|, |vifm-m_:cnewer|

--------------------------------------------------------------------------------
*vifm-custom-views*

Definition~

Normally, file views present a list of files from a single directory, but
sometimes it's useful to populate them with files from unrelated locations.
This is what custom views are mainly for.

Presentation~

Custom views are still related to the directory they were in before custom
list was loaded.  Path to that directory (original directory) can be seen in
the title of a custom view.

Files in the same directory have to be named differently but custom views are
free from this constraint, hence seeing file names alone might be rather
confusing.  In order to give an idea where files come from paths relative to
the original directory of the view are used, when that's not possible full
paths are shown.

Custom views normally don't contain any inexistent files.

Navigation/exiting~

Navigation in custom views somewhat differs compared to regular views.

gf - acts similar to |vifm-gf| on symbolic links and navigates to the file at
     its real location.

h - goes to the closest parent node in the tree view or terminates the custom
    view returning to the original directory.

gh - terminates the custom view returning to the original directory.

Going to the parent directory in other ways (whether by opening ".." entry or
executing `:cd ..`) also causes termination and return to the original
location.

All other ways of changing location (e.g., marks, bookmarks, |vifm-:cd|,
|vifm-:sync|) also cause termination of the custom view.

History~

Custom list exists only while it's visible, once left one can't return to it,
so there is no traces of it in any history.

Filters~

Only local filter affects contents of the view.  This is intentional.
Presumably, if one loads a particular list, precisely that list should be
displayed (except for inexistent paths, which are ignored).

Search~

Although directory names are visible in listing, they are not searchable.  Only
file names are taken into account (might be changed in the future, searching
whole lines seems quite reasonable).

Sorting~

Contrary to search sorting by name works on whole visible part of file path.

Highlight~

Whole file name is highlighted as one entity, even if there are directory
elements.

Updates~

Reloads can occur, though they are not automatic due to files being scattered
among different places.  On a reload inexistent files are removed and
meta-data of all other files is updated.

Once custom view forgets about the file, it won't add it back even if it's
created again.  So not seeing file previously affected by an operation which
was later undone is normal.

Operations~

All operations that add files are forbidden for custom views.  For example,
moving/copying/putting files into a custom view doesn't work, because that's
not a real file system location.

On the other hand, operations that use files of a custom view as a source
(e.g., yanking, copying, moving file from a custom view, deletion) and
operations that modify names are all allowed.

--------------------------------------------------------------------------------
*vifm-compare-views*

Kinds~

|vifm-:compare| can produce four different results depending on arguments:
 - single compare view (`ofone` and either `listall` or `listdups`);
 - single custom view (`ofone` and `listunique`);
 - two compare views (`ofboth` and either `listall` or `listdups`);
 - two custom views (`ofboth` and `listunique`).

The first two display files of a single file system tree.  Here duplicates are
files that have at least one copy in the same tree.  The other two kinds of
operation compare two trees, in which duplicates are files that are found in
both trees.

Lists of unique files are presented in custom views because there is no file
grouping to preserve as all file ids are guaranteed to be distinct.  See
|vifm-custom-views|.

Creation~

Arguments passed to |vifm-:compare| form seven categories each with its own
prefix and is responsible for particular property of the operation.

Which files to compare:
 - ofboth - compares files of two panes against each other;
 - ofone  - compares files of the same directory.

How files are compared:
 - byname     - by their name only;
 - bysize     - only by their size;
 - bycontents - by data they contain (combination of size and hash of
                small chunk of contents is used as first approximation,
                so don't worry too much about large files; non-regular files
                like pipes are assumed to be empty).

Which files to display:
 - listall    - all files;
 - listunique - unique files only;
 - listdups   - only duplicated files.

How results are grouped (has no effect if "ofone" specified):
 - groupids   - files considered identical are always adjacent in output;
 - grouppaths - file system ordering is preferred (this also enables
                displaying identically named files as mismatches).

Which files to omit:
 - skipempty - ignore empty files.

Comparison tweaks:
 - withicase - ignore case when comparing file names/paths;
 - withrcase - respect case when comparing file names/paths.

Which results to show (has no effect for single pane comparison):
 - showidentical   - control visibility of identical files;
 - showdifferent   - control visibility of changed files;
 - showuniqueleft  - control visibility of unique top/left files;
 - showuniqueright - control visibility of unique bottom/right files.

Each argument can appear multiple times, the rightmost one of the group
defines the behaviour.  All arguments alter default behaviour instead of
substituting it.

When neither `withicase` nor `withrcase` is specified, case depends on the
running operating system and the file system on which the files are located.

Exiting~

Comparing two views results in them entering a special state implemented on
top of custom views.  Both views leave this state when either of them stops
being custom.  Custom views terminate on changing to a different location or
as a result of a command like |vifm-:regular|, going into the parent directory
(like with |vifm-h| key or `:cd ..` command) returns to a regular state
without changing the location.  See |vifm-custom-views| for more details.

Examples~

The defaults correspond to probably the most common use case of comparing
files in two trees with grouping by paths, so the following are equivalent: >

 :compare
 :compare bycontents grouppaths
 :compare bycontents listall ofboth grouppaths
 :compare showidentical showdifferent showuniqueleft showuniqueright

Another use case is to find duplicates in the current sub-tree: >

 :compare listdups ofone

The following command lists files that are unique to each pane: >

 :compare listunique

Look~

The view can't switch to ls-like view as it's unable to display diff-like
data.

Comparison views have second column displaying id of the file, files with the
same id are considered to be equal.  The view columns configuration is
predefined.

The status bar displays only the initial result of the comparison and can be
out of date.

Behaviour~

When two views are being compared against one another the following changes to
the regular behaviour apply:
 - views are scrolled synchronously (as if |vifm-'scrollbind'| was set);
 - views' cursors are synchronized;
 - local filtering is disabled (its results wouldn't be meaningful);
 - |vifm-zd| excludes groups of adjacent identical files, 1zd gives usual
   behaviour;
 - sorting is permanently disabled (ordering is fixed);
 - removed files hide their counter pairs;
 - exiting one of the views terminates the other immediately;
 - renaming files isn't blocked, but isn't taken into account and might
   require regeneration of comparison;
 - entries which indicate absence of equivalent file have empty names and can
   be matched as such;
 - when unique files of both views are listed, custom views can be empty,
   this absence of unique files is stated clearly.

One compare view has similar properties (those that are applicable for single
pane).

Files are gathered in this way:
 - recursively starting at current location of the view;
 - dot files are excluded if view hides them at the moment of comparison, file
   name filters are obeyed as well so you end up comparing what you see;
 - directories are not taken into account;
 - symbolic links to directories are ignored.

--------------------------------------------------------------------------------
*vifm-startup*

On startup vifm determines several variables that are used during execution.
They are determined in the order they appear below.

                                               *vifm-$HOME*
On *nix systems $HOME is normally present and used as is.
On Windows systems vifm tries to find correct home directory in the following
order:
 - $HOME variable;
 - $USERPROFILE variable (on Windows only);
 - a combination of $HOMEDRIVE and $HOMEPATH variables (on Windows only).

                                               *vifm-$VIFM*
vifm tries to find correct configuration directory by checking the following
places:
 - $VIFM variable;
 - parent directory of the executable file (on Windows only);
 - $HOME/.vifm directory;
 - $APPDATA/Vifm directory (on Windows only);
 - $XDG_CONFIG_HOME/vifm directory;
 - $HOME/.config/vifm directory.

                                               *vifm-$MYVIFMRC*
vifm tries to find correct configuration file by checking the following places:
 - $MYVIFMRC variable;
 - vifmrc in parent directory of the executable file (on Windows only);
 - $VIFM/vifmrc file.

--------------------------------------------------------------------------------
*vifm-configure*

See |vifm-startup| section above for the explanations on |vifm-$VIFM| and
|vifm-$MYVIFMRC|.

                                               *vifm-vifmrc*
The vifmrc file contains commands that will be executed on vifm startup.  There
are two such files: global and local.  Global one is at
{prefix}/etc/vifm/vifmrc, see |vifm-$MYVIFMRC| variable description for the
search algorithm used to find local vifmrc.  Global vifmrc is loaded before the
local one, so that the later one can redefine anything configured globally.

Use vifmrc to set settings, mappings, filetypes etc.  To use multi line commands
precede each next line with a slash (whitespace before slash is ignored, but all
spaces at the end of the lines are saved).  For example:
set
    \smartcase
equals "setsmartcase".  When
set<space here>
    \ smartcase
equals "set  smartcase".

                                               *vifm-vifminfo*
The $VIFM/vifminfo file contains generic state of the application.  You can
control what is stored vifminfo by setting |vifm-'vifminfo'| option.  Vifm
always writes this file on exit unless |vifm-'vifminfo'| option is empty.
Marks, bookmarks, commands, histories, filetypes, fileviewers and registers
in the file are merged with vifm configuration.

Generally, runtime configuration has bigger priority during merging, but there
are some exceptions:
 - directory stack stored in the file is not overwritten unless something is
   changed in vifm instance that performs merge;
 - each mark or bookmark is marked with a timestamp, so that newer value is
   not overwritten by older one, thus no matter from where it comes, the
   newer one wins;
 - all histories are marked with timestamps on storing, this means that last
   instance to quit puts its elements on top of the list;
 - tabs are merged only if both current instance and stored state contain
   exactly one tab of any kind.

                                               *vifm-scripts*
The $VIFM/scripts directory can contain shell scripts.  vifm modifies
its PATH environment variable to let user run those scripts without specifying
full path.  All subdirectories of the $VIFM/scripts will be added to PATH too.
Script in a subdirectory overlaps script with the same name in all its parent
directories.

                                               *vifm-colors*
The $VIFM/colors/ and {prefix}/etc/vifm/colors/ directories contain color
schemes.  Available color schemes are searched in that order, so on name
conflict the one in $VIFM/colors/ wins.

Each color scheme should have ".vifm" extension.  This wasn't the case before
and for this reason the following rules apply during lookup:
 - if there is no file with .vifm extension, all regular files are listed;
 - otherwise only files with .vifm extension are listed (with the extension
   being truncated).

--------------------------------------------------------------------------------
*vifm-sessions*

Sessions provide a way to have multiple persistent runtime configurations.
Think of them as second-level |vifm-vifminfo| files in addition to the
first-level one used by all sessions.  In other words, they aren't a
replacement for vifminfo file that exists without sessions, but an addition to
it.  One can empty |vifm-'vifminfo'| option and rely solely on sessions, but in
practice one might want to share some state among instances in different
sessions or have an "out-of-sessions" state for tasks that don't deserve a
session of their own.

This leads to a two-level structure where data in session files has higher
priority than data in vifminfo files (where this makes sense) following the
same rules that merging of vifminfo file obeys.  In addition to that, history
items from session files are never ordered before history items from vifminfo
file.

Format~

Sessions have the format of vifminfo files, they do not consist of sequence
of command-line commands and are not meant to be sourced via |vifm-:source|
command.

Storage and naming~

`$VIFM/sessions/` directory serves as a storage for sessions.  Consequently
names should be valid filenames.  The structure of the storage is flat meaning
that there are no subdirectories, that's why names of sessions can't contain
slashes.

Usage model~

Contrary to Vim, vifm automates basic management of sessions.  You can start,
switch, stop or delete a session using builtin means.

Current session is saved at the same time vifminfo is saved (on normal exits
or explicitly on |vifm-:write| command) and right before switching to another
session.  To avoid saving in those cases use |vifm-:session| command to detach
(without saving) from a session before proceeding.

Related topics~

Commands: |vifm-:session|, |vifm-:delsession|
Options: |vifm-'sessionoptions'|
Variables: |vifm-v:session|

--------------------------------------------------------------------------------
*vifm-fuse*

vifm has a builtin support of automated FUSE file system mounts.  It is
implemented using file associations mechanism.  To enable automated mounts, one
needs to use a specially formatted program line in |vifm-:filetype| or
|vifm-:filextype| commands.  These use special macros, which differ from
macros in commands unrelated to FUSE.  Currently three formats are supported:

1) FUSE_MOUNT                                  *vifm-FUSE_MOUNT*
   This format should be used in case when all information needed for mounting
   all files of a particular type is the same.  E.g. mounting of tar files
   don't require any file specific options.

   Format line:
       FUSE_MOUNT|mounter %SOURCE_FILE %DESTINATION_DIR [%FOREGROUND]

   Example |vifm-:filetype| command: >
       :filetype FUSE_MOUNT|fuse-zip %SOURCE_FILE %DESTINATION_DIR
<

2) FUSE_MOUNT2                                 *vifm-FUSE_MOUNT2*
   This format allows to use specially formatted files to perform mounting and
   is useful for mounting remotes, for example remote file systems over ftp or
   ssh.

   Format line:
       FUSE_MOUNT2|mounter %PARAM %DESTINATION_DIR [%FOREGROUND]

   Example |vifm-:filetype| command: >
       :filetype *.ssh FUSE_MOUNT2|sshfs %PARAM %DESTINATION_DIR
<
   Example file content: >
       root@127.0.0.1:/
<

3) FUSE_MOUNT3                                 *vifm-FUSE_MOUNT3*
   This format is equivalent to |vifm-FUSE_MOUNT|, but omits unmounting.  It
   is useful for cases, when unmounting isn't needed, like when using AVFS.

   Example |vifm-:filetype| command: >
       :filetype *.tar,*.tar.bz2,*.tbz2,*.tgz,*.tar.gz,*.tar.xz,*.txz,*.deb
            \ {Mount with avfs}
            \ FUSE_MOUNT3|mount-avfs %DESTINATION_DIR %SOURCE_FILE
<
   Example `mount-avfs` helper script: >
       #!/bin/sh

       dest=$1
       file=$2

       rmdir "$dest"
       ln -s "$HOME/.avfs$file#/" "$dest"

All % macros are expanded by vifm at runtime and have the following meaning:
   - %SOURCE_FILE is replaced by full path to selected file;
   - %DESTINATION_DIR is replaced by full path to mount directory, which is
     created by vifm basing on the value of |vifm-'fusehome'| option;
   - %PARAM value is filled from the first line of file (whole line), though
     in the future it can be changed to whole file content;
   - %FOREGROUND means that you want to run mount command as a regular
     command (required to be able to provide input for communication with
     mounter in interactive way).

%FOREGROUND is an optional macro.  Other macros are not mandatory, but mount
commands likely won't work without them.

%CLEAR is obsolete name of %FOREGROUND, which is still supported, but might be
removed in future.  Its use is discouraged.

Unlike macros elsewhere, these are recognized only if they appear at the end
of a command or are followed by a space.  There is no way to escape % either.
These are historical limitations, which might be addressed in the future.

The mounted FUSE file systems will be automatically unmounted in two cases:
   - when vifm quits (with |vifm-ZZ|, |vifm-:q|, etc. or when killed by signal);
   - when you explicitly leave mount point going up to its parent directory
     (with |vifm-h|, |vifm-Enter| on "../" or ":cd ..") and other pane is not
     in the same directory or its child directories.

--------------------------------------------------------------------------------
*vifm-view-look*

vifm supports displaying of file list view in two different ways:
   - in a table mode, when multiple columns can be set using |vifm-'viewcolumns'|
     option (see |vifm-column-view| for details);
   - in a multicolumn list manner which looks almost like `ls -x` command
     output (see |vifm-ls-view| for details).

The look is local for each view and can be chosen by changing value of the
|vifm-'lsview'| boolean option.

Depending on view look some of keys change their meaning to allow more natural
cursor moving.  This concerns mainly |vifm-h|, |vifm-j|, |vifm-k|, |vifm-l| and other
similar navigation keys.

Also some of options can be ignored if they don't affect view displaying in
selected look.  For example value of |vifm-'viewcolumns'| when |vifm-'lsview'| is
set.

--------------------------------------------------------------------------------
*vifm-ls-view*

When this view look is enabled by setting |vifm-'lsview'| option on, vifm will
display files in multiple columns.  Number of columns depends on the length of
the longest file name present in current directory of the view.  Whole file
list is automatically reflowed on directory change, terminal or view resize.

View looks close to output of `ls -x` command, so files are listed left to
right in rows.

In this mode file manipulation commands (e.g. |vifm-d|) don't work line-wise like
they do in Vim, since such operations would be uncommon for file manipulation
tasks.  Thus, for example, |vifm-dd| will remove only current file.

By default the view is filled by lines, |vifm-'lsoptions'| can be used to get
filling by columns.

Note that tree-view and compare view inhibit ls-like view.

--------------------------------------------------------------------------------
*vifm-column-view*

View columns are described by a comma-separated list of column descriptions,
each of which has the following format >
    [ '-' | '*' ] [ fw ( [ '.' tw ] | '%' ) ] '{' type | literal '}' '.'{0,3}
where fw stands for full width, tw stands for text width, bar is logical or,
square brackets denote optional parts and curly braces define range of
repetitions for a symbol that precedes them.

So it basically consists of four parts:
 1. Optional alignment specifier
 2. Optional width specifier
 3. Mandatory column name
 4. Optional cropping specifier

Alignment specifier~

It's an optional minus or asterisk sign as the first symbol of the string.

Specifies type of text alignment within a column.  Two types are supported:

 - left align >

     set viewcolumns=-{name}
<
 - right align (default) >

     set viewcolumns={name}
<
 - middle align

    It's like left alignment, but when the text is bigger than the column, it
    is cut in the middle (so the start and the end of the field are always
    visible). >

     set viewcolumns=^{name}
<
 - dynamic align

    It's like left alignment, but when the text is bigger than the column,
    the alignment is made at the right (so the part of the field is always
    visible). >

     set viewcolumns=*{name}
<
Width specifier~

It's a number followed by a percent sign, two numbers (second one should be
less than or equal to the first one) separated with a dot or a single number.

Specifies column width and its units. There are three size types:
 - absolute size - column width is specified in characters >
     set viewcolumns=-100{name},20.15{ext}
<  results in two columns with lengths of 100 and 20 and a reserved space of
   five characters on the left of second column.
 - relative (percent) size - column width is specified in percents of view width >
     set viewcolumns=-80%{name},15%{ext},5%{mtime}
<  results in three columns with lengths of 80/100, 15/100 and 5/100 of view
   width.
 - auto size (default) - column width is automatically determined >
     set viewcolumns=-{name},{ext},{mtime}
<  results in three columns with length of one third of view width. There is
   no size adjustment to content, since it will slow down rendering.

Columns of different sizing types can be freely mixed in one view. Though
sometimes some of columns can be seen partly or be completely invisible if
there is not enough space to display them.

Column contents~

This is usually a sorting key surrounded with curly braces, e.g. >
    {name},{ext},{mtime}
<
{name} and {iname} types are the same and are both present for consistency
with |vifm-'sort'| option.

The following column types don't have corresponding sorting keys:
 - {root}     - display name without extension (as a complement for {ext})
 - {fileroot} - display name without extension for anything except for
                directories and symbolic links to directories (as a
                complement for {fileext})

Empty curly braces ({}) are replaced with the default secondary column for
primary sort key.  So after the next command views will be displayed almost as
if |vifm-'viewcolumns'| was empty, but adding ellipsis for long file names: >
    set viewcolumns=-{name}..,6{}.

The last kind of column value is a string literal.  The literal is used as a
column value for every row.  The syntax is `{#literal}`, examples: >
    " double-character pseudo-padding on both sides
    set viewcolumns='2{#},*{name}..,{},2{#}'
    " pseudo-border between columns
    set viewcolumns='*{name}..,{#|},6{}'
    " pseudo-border with padding between columns
    set viewcolumns='*{name}..,{# | },6{}'
This can be used to draw column separators.  Mind that for convenience
literals have different defaults: truncation and automatically determined
absolute size, which is what you usually want for them.  Make sure to quote or
escape spaces, vertical bars and other special symbols when using them as part
of literals.

Cropping specifier~

It's from one to three dots after closing curly brace in column format.

Specifies type of text truncation if it doesn't fit in the column.  Currently
three types are supported:
 - truncation - text is truncated >
     set viewcolumns=-{name}.
<  results in truncation of names that are too long too fit in the view.
 - adding of ellipsis - ellipsis on the left or right are added when needed >
     set viewcolumns=-{name}..
<  results in that ellipsis are added at the end of too long file names.
 - none (default) - text can pass column boundaries >
     set viewcolumns=-{name}...,{ext}
<  results in that long file names can partially be written on the ext column.

--------------------------------------------------------------------------------
*vifm-color-schemes*

The color schemes in vifm can be applied in two different ways:
   - as the primary color scheme
   - as local to a pane color scheme

Both types are set using |vifm-:colorscheme| command, but of different forms:
   - :colorscheme color_scheme_name - for the primary color scheme
   - :colorscheme color_scheme_name directory - for local color schemes

Look of different parts of the TUI (Text User Interface) is determined in
this way:
   - Border, TabLine, TabLineSel, TopLineSel, TopLine, CmdLine, ErrorMsg,
     StatusLine, JobLine, SuggestBox, WildBox and WildMenu are always determined
     by the primary color scheme
   - CurrLine, Selected, Directory, Link, BrokenLink, Socket, Device,
     Executable, Fifo, CmpMismatch, CmpUnmatched, CmpBlank, Win, AuxWin and
     OtherWin are determined by primary color scheme and a set of local color
     schemes, which can be empty

There might be a set of local color schemes because they are structured
hierarchically according to file system structure. For example, having the
following piece of file system: >

 ~
 `-- bin
    |
    `-- my
<
Two color schemes: >

 # ~/.config/vifm/colors/for_bin.vifm
 highlight Win cterm=none ctermfg=white ctermbg=red
 highlight CurrLine cterm=none ctermfg=red ctermbg=black

 # ~/.config/vifm/colors/for_bin_my.vifm
 highlight CurrLine cterm=none ctermfg=green ctermbg=black
<
And these three commands in the vifmrc file: >

 colorscheme Default
 colorscheme for_bin ~/bin
 colorscheme for_bin_my ~/bin/my
<
File list will look in the following way for each level:
   - ~/ - Default color scheme
       black background
       cursor with blue background
   - ~/bin/ - mix of Default and for_bin color schemes
       red background
       cursor with black background and red foreground
   - ~/bin/my/ - mix of Default, for_bin and for_bin_my color schemes
       red background
       cursor with black background and green foreground

--------------------------------------------------------------------------------
*vifm-trash*

vifm has support of trash directory, which is used as temporary storage for
deleted files or files that were cut.  Using trash is controlled by the
|vifm-'trash'| option, and exact path to the trash can be set with
|vifm-'trashdir'| option.  Trash directory in vifm differs from the system-wide
one by default, because of possible incompatibilities of storing deleted files
among different file managers.  But one can set |vifm-'trashdir'| to
"~/.local/share/Trash" to use a "standard" trash directory.

There are two scenarios of using trash in vifm:

1. As a place for storing files that were cut by |vifm-d| and may be
   inserted to some other place in file system.
2. As a storage of files, that are deleted but not purged yet.

The first scenario uses deletion (|vifm-d|) operations to put files to
trash and put (|vifm-p|) operations to restore files from trash directory.
Note that such operations move files to and from trash directory,
which can be long term operations in case of different partitions or
remote drives mounted locally.

The second scenario uses deletion (|vifm-d|) operations for moving files
to trash directory and |vifm-:empty| command-line command to purge all
previously deleted files.

Deletion and put operations depend on registers, which can point to files in
trash directory.  Normally, there are no nonexistent files in registers, but
vifm doesn't keep track of modifications under trash directory, so one
shouldn't expect value of registers to be absolutely correct if trash
directory was modified not by operation that are meant for it.  But this
won't lead to any issues with operations, since they ignore nonexistent
files.

--------------------------------------------------------------------------------
*vifm-file-copying*

For enabling copy-on-write of BTRFS on Linux, set "fastfilecloning" flag of
|vifm-'iooptions'|.

File copying within an XFS file system uses reflinks by default.  Any file
copied from another file system will be copied without reflinks even if it has
a matching list of XFS extents.  Reflinks are not guaranteed when using
external programs.  This behaviour was observed on Linux and doesn't
necessarily hold for other environments.

--------------------------------------------------------------------------------
*vifm-clientserver*

vifm supports remote execution of command-line mode commands, remote changing of
directories and expression evaluation.  This is possible using |vifm---remote|
and |vifm---remote-expr| command-line arguments.

To execute a command remotely combine --remote argument with |vifm--c| or
|vifm--+c|.  For example: >
    vifm --remote -c 'cd /'
    vifm --remote '+cd /'
<
To change directory not using command-line mode commands one can specify paths
right after --remote argument, like this: >
    vifm --remote /
    vifm --remote ~
    vifm --remote /usr/bin /tmp

Evaluating expression remotely might be useful to query information about an
instance, for example its location: >
    vifm --remote-expr 'expand("%d")'

If there are several running instances, the target can be specified with
|vifm---server-name| option (otherwise, the first one lexicographically is used): >
    vifm --server-name work --remote ~/work/project

List of names of running instances can be obtained via |vifm---server-list|
option.  Name of the current one is available via v:servername.

                                               *vifm-v:servername*
v:servername                                   *vifm-servername-variable*
    server name of the running vifm instance.  Empty if client-server feature
    is disabled.

--------------------------------------------------------------------------------
*vifm-ext-rename*

When an editor is run to edit list of file names, contents of the temporary file
has the following format:
 1. Order of lines correspond to the order of files in a view.
 2. Lines that start with a "#" are comments and are ignored.
 3. Single backslash at the beginning of a line is ignored, so that a file
    starting with a backslash will appear like "\#name".

If an operation was rejected due to issues with file names, next time you'll see
the following in this order:
 1. Last error (in comments).
 2. Original file names (in comments).
 3. Failed list of new names.

Mind that |vifm-plugin| will extract list of original names and show them in a
vertical split.

You can cancel renaming by removing all non-comments from the buffer.  This
also erases information about previous edits.

--------------------------------------------------------------------------------
*vifm-mouse-using*

Note: <ScrollWheelDown> is not available on 32-bit *nix systems, because
ncurses doesn't support it there (limitation of implementation).

Note: these are not available in mappings at the moment.

                                               *vifm-mouse-overview*
Normal Mode:
event             position  change  action        ~
                   cursor   window                ~
<LeftMouse>         yes      yes    <cr> if cursor wasn't moved
<LeftRelease>        no      yes
<MiddleMouse>        no      yes    <c-e>
<MiddleRelease>      no      yes
<RightMouse>        yes      yes    |vifm-:file|
<RightRelease>       no      yes
<ScrollWheelUp>      no      yes    <c-y> or |vifm-:tabprevious|
<ScrollWheelDown>    no      yes    <c-e> or |vifm-:tabnext|

Clicking on or scrolling over an inactive pane (including its title), makes it
active and does nothing else.  Tabs are scrolled when mouse hovers over them.

Clicking on the left miller column goes to parent directory and clicking the
right one opens current entry.

Visual Mode:
event             position  selection  action     ~
                   cursor                         ~
<LeftMouse>         yes      update    <cr> if cursor wasn't moved
<LeftRelease>        no
<MiddleMouse>        no      update    <c-e>
<MiddleRelease>      no
<RightMouse>         no
<RightRelease>       no
<ScrollWheelUp>      no      update    <c-y>
<ScrollWheelDown>    no      update    <c-e>

Command-line Mode:
event             position  action                ~
                   cursor                         ~
<LeftMouse>         yes
<LeftRelease>        no
<MiddleMouse>        no     <c-n>
<MiddleRelease>      no
<RightMouse>         no
<RightRelease>       no
<ScrollWheelUp>      no     <c-p>
<ScrollWheelDown>    no     <c-n>

Menu Mode:
event             position  action                ~
                   cursor                         ~
<LeftMouse>         yes     <cr> if cursor wasn't moved
<LeftRelease>        no
<MiddleMouse>        no     <c-e>
<MiddleRelease>      no
<RightMouse>         no
<RightRelease>       no
<ScrollWheelUp>      no     <c-y>
<ScrollWheelDown>    no     <c-e>

View Mode:
event               action                ~
                                          ~
<ScrollWheelUp>     k
<ScrollWheelDown>   j

Clicking on or scrolling over an inactive pane (including its title), detaches
view mode if it wasn't activated for exploring a file.

--------------------------------------------------------------------------------
*vifm-plugin*

See |vifm-plugin.txt|.

--------------------------------------------------------------------------------
*vifm-reserved*

The following command names are reserved and shouldn't be used for user
commands.

  g[lobal]
  v[global]

--------------------------------------------------------------------------------
*vifm-env-vars*

|vifm-$VIFM|
Points to main configuration directory (usually ~/.config/vifm/).

|vifm-$MYVIFMRC|
Points to main configuration file (usually ~/.config/vifm/vifmrc).

These environment variables are valid inside vifm and also can be used to
configure it by setting some of them before running vifm.

When $MYVIFMRC isn't set, it's made as $VIFM/vifmrc (exception for Windows:
vifmrc in the same directory as vifm.exe has higher priority than
$VIFM/vifmrc).

See |vifm-startup| section above for more details.

                                               *vifm-$VIFM_FUSE_FILE*
On execution of external commands this variable is set to the full path of file
used to initiate FUSE mount of the closest mount point from current pane's
directory up.  It's not set when outside FUSE mount point.  When vifm is used
inside terminal multiplexer, it tries to set this variable as well (it doesn't
work this way on its own).

--------------------------------------------------------------------------------
*vifm-see-also*

Vim plugin documentation: |vifm-plugin.txt|

Website: https://vifm.info/
Wiki: https://wiki.vifm.info/

--------------------------------------------------------------------------------
 vim:tw=78:fo=tcq2:isk=!-~,^*,^\|,^\":ts=8:sw=4:ft=help:norl:
